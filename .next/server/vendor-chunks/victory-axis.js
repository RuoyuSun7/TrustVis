"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/victory-axis";
exports.ids = ["vendor-chunks/victory-axis"];
exports.modules = {

/***/ "(ssr)/./node_modules/victory-axis/es/helper-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/victory-axis/es/helper-methods.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBaseProps: () => (/* binding */ getBaseProps),\n/* harmony export */   getStyles: () => (/* binding */ getStyles)\n/* harmony export */ });\n/* harmony import */ var lodash_defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/defaults */ \"(ssr)/./node_modules/lodash/defaults.js\");\n/* harmony import */ var lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_defaults__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/axis.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/scale.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/helpers.js\");\n\n\nconst orientationSign = {\n  top: -1,\n  left: -1,\n  right: 1,\n  bottom: 1\n};\nconst exists = val => val !== null && val !== undefined;\nconst getCurrentAxis = (props, axis) => {\n  const {\n    orientation,\n    horizontal\n  } = props;\n  if (orientation) {\n    const dimensions = {\n      top: \"x\",\n      bottom: \"x\",\n      left: \"y\",\n      right: \"y\"\n    };\n    return dimensions[orientation];\n  }\n  const otherAxis = axis === \"x\" ? \"y\" : \"x\";\n  return horizontal ? otherAxis : axis;\n};\nconst getScale = props => {\n  const axis = victory_core__WEBPACK_IMPORTED_MODULE_1__.getAxis(props);\n  const currentAxis = getCurrentAxis(props, axis);\n  const scale = victory_core__WEBPACK_IMPORTED_MODULE_2__.getBaseScale(props, axis);\n  const propsDomain = props.domain && props.domain[axis];\n  const domain = propsDomain || victory_core__WEBPACK_IMPORTED_MODULE_1__.getDomain(props) || scale.domain();\n  scale.range(victory_core__WEBPACK_IMPORTED_MODULE_3__.getRange(props, currentAxis));\n  scale.domain(domain);\n  return scale;\n};\nconst getStyleObject = props => {\n  const {\n    theme,\n    dependentAxis\n  } = props;\n  const generalAxisStyle = theme && theme.axis && theme.axis.style;\n  const axisType = dependentAxis ? \"dependentAxis\" : \"independentAxis\";\n  const specificAxisStyle = theme && theme[axisType] && theme[axisType].style;\n  const mergeStyles = () => {\n    const styleNamespaces = [\"axis\", \"axisLabel\", \"grid\", \"parent\", \"tickLabels\", \"ticks\"];\n    return styleNamespaces.reduce((memo, curr) => {\n      memo[curr] = lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()({}, specificAxisStyle[curr], generalAxisStyle[curr]);\n      return memo;\n    }, {});\n  };\n  return generalAxisStyle && specificAxisStyle ? mergeStyles() : specificAxisStyle || generalAxisStyle;\n};\nconst getStyles = function (props, styleObject) {\n  if (styleObject === void 0) {\n    styleObject = {};\n  }\n  const style = props.style || {};\n  const parentStyleProps = {\n    height: \"100%\",\n    width: \"100%\"\n  };\n  return {\n    parent: lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()(style.parent, styleObject.parent, parentStyleProps),\n    axis: lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()({}, style.axis, styleObject.axis),\n    axisLabel: lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()({}, style.axisLabel, styleObject.axisLabel),\n    grid: lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()({}, style.grid, styleObject.grid),\n    ticks: lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()({}, style.ticks, styleObject.ticks),\n    tickLabels: lodash_defaults__WEBPACK_IMPORTED_MODULE_0___default()({}, style.tickLabels, styleObject.tickLabels)\n  };\n};\nconst getTickProps = (layout, style, datum) => {\n  const {\n    position,\n    transform\n  } = layout;\n  return {\n    x1: transform.x,\n    y1: transform.y,\n    x2: transform.x + position.x2,\n    y2: transform.y + position.y2,\n    style,\n    datum\n  };\n};\n\n// eslint-disable-next-line max-params\nconst getTickLabelProps = (layout, style, anchors, datum, text) => {\n  const {\n    position,\n    transform\n  } = layout;\n  return {\n    style,\n    x: transform.x + position.x,\n    y: transform.y + position.y,\n    verticalAnchor: anchors.verticalAnchor,\n    textAnchor: anchors.textAnchor,\n    angle: style.angle,\n    text,\n    datum\n  };\n};\nconst getGridProps = (layout, style, datum) => {\n  const {\n    edge,\n    transform\n  } = layout;\n  return {\n    x1: transform.x,\n    y1: transform.y,\n    x2: edge.x + transform.x,\n    y2: edge.y + transform.y,\n    style,\n    datum\n  };\n};\nconst getAxisProps = (modifiedProps, calculatedValues, globalTransform) => {\n  const {\n    style,\n    padding,\n    isVertical\n  } = calculatedValues;\n  const {\n    width,\n    height\n  } = modifiedProps;\n  return {\n    style: style.axis,\n    x1: isVertical ? globalTransform.x : padding.left + globalTransform.x,\n    x2: isVertical ? globalTransform.x : width - padding.right + globalTransform.x,\n    y1: isVertical ? padding.top + globalTransform.y : globalTransform.y,\n    y2: isVertical ? height - padding.bottom + globalTransform.y : globalTransform.y\n  };\n};\nconst getEvaluatedStyles = (style, props) => {\n  return {\n    tickStyle: victory_core__WEBPACK_IMPORTED_MODULE_3__.evaluateStyle(style.ticks, props),\n    labelStyle: victory_core__WEBPACK_IMPORTED_MODULE_3__.evaluateStyle(style.tickLabels, props),\n    gridStyle: victory_core__WEBPACK_IMPORTED_MODULE_3__.evaluateStyle(style.grid, props)\n  };\n};\nconst getAxisLabelProps = (props, calculatedValues, globalTransform) => {\n  const {\n    style,\n    orientation,\n    padding,\n    labelPadding,\n    isVertical\n  } = calculatedValues;\n  const sign = orientationSign[orientation];\n  const hPadding = padding.left + padding.right;\n  const vPadding = padding.top + padding.bottom;\n  const verticalAnchor = sign < 0 ? \"end\" : \"start\";\n  const labelStyle = style.axisLabel;\n  const angle = isVertical ? -90 : 0; // eslint-disable-line no-magic-numbers\n  const x = isVertical ? globalTransform.x + sign * labelPadding : (props.width - hPadding) / 2 + padding.left + globalTransform.x;\n  const y = isVertical ? (props.height - vPadding) / 2 + padding.top + globalTransform.y : sign * labelPadding + globalTransform.y;\n  return {\n    x,\n    y,\n    verticalAnchor: labelStyle.verticalAnchor || verticalAnchor,\n    textAnchor: labelStyle.textAnchor || \"middle\",\n    angle: labelStyle.angle === undefined ? angle : labelStyle.angle,\n    style: labelStyle,\n    text: props.label\n  };\n};\nconst getAnchors = (orientation, isVertical) => {\n  const anchorOrientation = {\n    top: \"end\",\n    left: \"end\",\n    right: \"start\",\n    bottom: \"start\"\n  };\n  const anchor = anchorOrientation[orientation];\n  return {\n    textAnchor: isVertical ? anchor : \"middle\",\n    verticalAnchor: isVertical ? \"middle\" : anchor\n  };\n};\nconst getLabelPadding = (props, style) => {\n  const labelStyle = style.axisLabel || {};\n  if (labelStyle.padding !== undefined && labelStyle.padding !== null) {\n    return labelStyle.padding;\n  }\n  const isVertical = victory_core__WEBPACK_IMPORTED_MODULE_1__.isVertical(props);\n  // TODO: magic numbers\n  /* eslint-disable no-magic-numbers*/\n  const fontSize = labelStyle.fontSize || 14;\n  return props.label ? fontSize * (isVertical ? 2.3 : 1.6) : 0;\n  /* eslint-enable no-magic-numbers*/\n};\nconst getDefaultOrientations = (axis, originSign, horizontal) => {\n  const sign = originSign || \"positive\";\n  const orientations = {\n    positive: {\n      x: \"bottom\",\n      y: \"left\"\n    },\n    negative: {\n      x: \"top\",\n      y: \"right\"\n    }\n  };\n  const horizontalOrientations = {\n    positive: {\n      x: \"left\",\n      y: \"bottom\"\n    },\n    negative: {\n      x: \"right\",\n      y: \"top\"\n    }\n  };\n  return horizontal ? horizontalOrientations[sign][axis] : orientations[sign][axis];\n};\nconst getStandaloneOffset = (props, calculatedValues) => {\n  const {\n    style,\n    scale,\n    orientation,\n    padding,\n    axis,\n    ticks,\n    stringTicks,\n    isVertical,\n    labelPadding\n  } = calculatedValues;\n  const {\n    polar,\n    horizontal\n  } = props;\n  const sharedProps = {\n    scale: {\n      [axis]: scale\n    },\n    polar,\n    horizontal,\n    ticks,\n    stringTicks\n  };\n  const xPadding = orientation === \"right\" ? padding.right : padding.left;\n  const yPadding = orientation === \"top\" ? padding.top : padding.bottom;\n  const offsetX = props.offsetX !== null && props.offsetX !== undefined ? props.offsetX : xPadding;\n  const offsetY = props.offsetY !== null && props.offsetY !== undefined ? props.offsetY : yPadding;\n  const fontSize = style.axisLabel.fontSize || 14; // eslint-disable-line no-magic-numbers\n  const tickSizes = ticks.map((data, index) => {\n    const tick = stringTicks ? props.tickValues[data - 1] : data;\n    const tickStyle = victory_core__WEBPACK_IMPORTED_MODULE_3__.evaluateStyle(style.ticks, Object.assign({}, sharedProps, {\n      tick,\n      index\n    }));\n    return tickStyle.size || 0;\n  });\n  const totalPadding = fontSize + 2 * Math.max(...tickSizes) + labelPadding;\n  const minimumPadding = 1.2 * fontSize; // eslint-disable-line no-magic-numbers\n  const x = isVertical ? totalPadding : minimumPadding;\n  const y = isVertical ? minimumPadding : totalPadding;\n  return {\n    x: offsetX !== null && offsetX !== undefined ? offsetX : x,\n    y: offsetY !== null && offsetY !== undefined ? offsetY : y\n  };\n};\nconst isEqual = (a, b) => {\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  return a === b;\n};\n\n// eslint-disable-next-line complexity\nconst getOffset = (props, calculatedValues) => {\n  const {\n    scale,\n    origin,\n    orientation,\n    orientations,\n    domain,\n    padding\n  } = calculatedValues;\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = padding;\n  const calculatedOrientation = {\n    x: orientation === \"bottom\" || orientation === \"top\" ? orientation : orientations.x,\n    y: orientation === \"left\" || orientation === \"right\" ? orientation : orientations.y\n  };\n\n  // make the axes line up, and cross when appropriate\n  const orientationOffset = {\n    x: calculatedOrientation.y === \"left\" ? left : right,\n    y: calculatedOrientation.x === \"bottom\" ? bottom : top\n  };\n  const originOffset = {\n    x: calculatedOrientation.y === \"left\" ? 0 : props.width,\n    y: calculatedOrientation.x === \"bottom\" ? props.height : 0\n  };\n  const originPosition = {\n    x: isEqual(origin.x, domain.x[0]) || isEqual(origin.x, domain.x[1]) ? 0 : scale.x(origin.x),\n    y: isEqual(origin.y, domain.y[0]) || isEqual(origin.y, domain.y[1]) ? 0 : scale.y(origin.y)\n  };\n  const x = originPosition.x ? Math.abs(originOffset.x - originPosition.x) : orientationOffset.x;\n  const y = originPosition.y ? Math.abs(originOffset.y - originPosition.y) : orientationOffset.y;\n  const offsetX = exists(props.offsetX) ? props.offsetX : x;\n  const offsetY = exists(props.offsetY) ? props.offsetY : y;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n};\n\n// eslint-disable-next-line complexity\nconst getHorizontalOffset = (props, calculatedValues) => {\n  const {\n    scale,\n    origin,\n    orientation,\n    orientations,\n    domain,\n    padding\n  } = calculatedValues;\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = padding;\n  const calculatedOrientation = {\n    y: orientation === \"bottom\" || orientation === \"top\" ? orientation : orientations.x,\n    x: orientation === \"left\" || orientation === \"right\" ? orientation : orientations.y\n  };\n\n  // make the axes line up, and cross when appropriate\n  const orientationOffset = {\n    x: calculatedOrientation.y === \"bottom\" ? bottom : top,\n    y: calculatedOrientation.x === \"left\" ? left : right\n  };\n  const originOffset = {\n    y: calculatedOrientation.x === \"left\" ? 0 : props.width,\n    x: calculatedOrientation.y === \"bottom\" ? props.height : 0\n  };\n  const originPosition = {\n    x: isEqual(origin.x, domain.x[0]) || isEqual(origin.x, domain.x[1]) ? 0 : scale.x(origin.x),\n    y: isEqual(origin.y, domain.y[0]) || isEqual(origin.y, domain.y[1]) ? 0 : scale.y(origin.y)\n  };\n  const y = originPosition.x ? Math.abs(originOffset.x - originPosition.x) : orientationOffset.x;\n  const x = originPosition.y ? Math.abs(originOffset.y - originPosition.y) : orientationOffset.y;\n  const offsetX = exists(props.offsetX) ? props.offsetX : x;\n  const offsetY = exists(props.offsetY) ? props.offsetY : y;\n  return {\n    x: offsetX,\n    y: offsetY\n  };\n};\nconst getTransform = (props, calculatedValues, offset) => {\n  const {\n    orientation,\n    axis\n  } = calculatedValues;\n  const axisValue = victory_core__WEBPACK_IMPORTED_MODULE_1__.getAxisValue(props, axis);\n  return {\n    top: {\n      x: 0,\n      y: axisValue !== undefined ? axisValue : offset.y\n    },\n    bottom: {\n      x: 0,\n      y: axisValue !== undefined ? axisValue : props.height - offset.y\n    },\n    left: {\n      x: axisValue !== undefined ? axisValue : offset.x,\n      y: 0\n    },\n    right: {\n      x: axisValue !== undefined ? axisValue : props.width - offset.x,\n      y: 0\n    }\n  }[orientation];\n};\nconst getTickPosition = (style, orientation, isVertical) => {\n  const {\n    tickStyle,\n    labelStyle\n  } = style;\n  const size = tickStyle.size || 0;\n  const tickPadding = tickStyle.padding || 0;\n  const labelPadding = labelStyle.padding || 0;\n  const tickSpacing = size + tickPadding + labelPadding;\n  const sign = orientationSign[orientation];\n  return {\n    x: isVertical ? sign * tickSpacing : 0,\n    x2: isVertical ? sign * size : 0,\n    y: isVertical ? 0 : sign * tickSpacing,\n    y2: isVertical ? 0 : sign * size\n  };\n};\nconst getTickTransform = (tick, globalTransform, isVertical) => {\n  return {\n    x: isVertical ? globalTransform.x : tick + globalTransform.x,\n    y: isVertical ? tick + globalTransform.y : globalTransform.y\n  };\n};\nconst getGridEdge = (props, calculatedValues) => {\n  const {\n    orientation,\n    padding,\n    isVertical\n  } = calculatedValues;\n  const sign = -orientationSign[orientation];\n  const x = isVertical ? sign * (props.width - (padding.left + padding.right)) : 0;\n  const y = isVertical ? 0 : sign * (props.height - (padding.top + padding.bottom));\n  return {\n    x,\n    y\n  };\n};\nconst getGridOffset = (calculatedValues, offset) => {\n  const {\n    padding,\n    orientation,\n    crossAxis\n  } = calculatedValues;\n  const xPadding = orientation === \"right\" ? padding.right : padding.left;\n  const yPadding = orientation === \"top\" ? padding.top : padding.bottom;\n  return {\n    x: crossAxis ? offset.x - xPadding : 0,\n    y: crossAxis ? offset.y - yPadding : 0\n  };\n};\nconst getLayoutProps = (modifiedProps, calculatedValues) => {\n  let offset;\n  if (calculatedValues.domain.x && calculatedValues.domain.y) {\n    offset = modifiedProps.horizontal ? getHorizontalOffset(modifiedProps, calculatedValues) : getOffset(modifiedProps, calculatedValues);\n  } else {\n    offset = getStandaloneOffset(modifiedProps, calculatedValues);\n  }\n  return {\n    globalTransform: getTransform(modifiedProps, calculatedValues, offset),\n    gridOffset: getGridOffset(calculatedValues, offset),\n    gridEdge: getGridEdge(modifiedProps, calculatedValues)\n  };\n};\nconst getOrientation = props => {\n  if (props.orientation) {\n    return props.orientation;\n  }\n  const defaultOrientations = {\n    dependent: props.horizontal ? \"bottom\" : \"left\",\n    independent: props.horizontal ? \"left\" : \"bottom\"\n  };\n  return props.dependentAxis ? defaultOrientations.dependent : defaultOrientations.independent;\n};\n\n// eslint-disable-next-line complexity\nconst getCalculatedValues = props => {\n  const defaultStyles = getStyleObject(props);\n  const style = getStyles(props, defaultStyles);\n  const padding = victory_core__WEBPACK_IMPORTED_MODULE_3__.getPadding(props);\n  const labelPadding = getLabelPadding(props, style);\n  const stringTicks = victory_core__WEBPACK_IMPORTED_MODULE_1__.stringTicks(props) ? props.tickValues : undefined;\n  const axis = victory_core__WEBPACK_IMPORTED_MODULE_1__.getAxis(props);\n  const axisDomain = victory_core__WEBPACK_IMPORTED_MODULE_1__.getDomain(props);\n  const axisScale = getScale(props);\n  const xAxisDomain = axis === \"x\" ? axisDomain : undefined;\n  const yAxisDomain = axis === \"y\" ? axisDomain : undefined;\n  const xAxisScale = axis === \"x\" ? axisScale : undefined;\n  const yAxisScale = axis === \"y\" ? axisScale : undefined;\n  const crossAxis = !(props.crossAxis === false || props.standalone === true);\n  const ticks = victory_core__WEBPACK_IMPORTED_MODULE_1__.getTicks(props, axisScale, crossAxis);\n  const tickFormat = victory_core__WEBPACK_IMPORTED_MODULE_1__.getTickFormat(props, axisScale);\n  const range = {\n    x: victory_core__WEBPACK_IMPORTED_MODULE_3__.getRange(props, \"x\"),\n    y: victory_core__WEBPACK_IMPORTED_MODULE_3__.getRange(props, \"y\")\n  };\n  // use full domain if passed in from parent,\n  // otherwise use the just the one axis available\n  const domain = {\n    x: props.domain && props.domain.x ? props.domain.x : xAxisDomain,\n    y: props.domain && props.domain.y ? props.domain.y : yAxisDomain\n  };\n  // use full scale if passed in from parent,\n  // otherwise use the just the one axis available\n  const scale = {\n    x: props.domain && props.domain.x ? victory_core__WEBPACK_IMPORTED_MODULE_2__.getBaseScale(props, \"x\").domain(props.domain.x).range(props.horizontal ? range.y : range.x) : xAxisScale,\n    y: props.domain && props.domain.y ? victory_core__WEBPACK_IMPORTED_MODULE_2__.getBaseScale(props, \"y\").domain(props.domain.y).range(props.horizontal ? range.x : range.y) : yAxisScale\n  };\n  const origin = domain.x && domain.y ? victory_core__WEBPACK_IMPORTED_MODULE_1__.getOrigin(domain) : undefined;\n  const originSign = origin ? {\n    x: victory_core__WEBPACK_IMPORTED_MODULE_1__.getOriginSign(origin.x, domain.x),\n    y: victory_core__WEBPACK_IMPORTED_MODULE_1__.getOriginSign(origin.y, domain.y)\n  } : undefined;\n  const orientations = originSign ? {\n    x: getDefaultOrientations(\"x\", originSign.y, props.horizontal),\n    y: getDefaultOrientations(\"y\", originSign.x, props.horizontal)\n  } : undefined;\n  const orientation = orientations ? props.orientation || orientations[axis] : getOrientation(props);\n  const isVertical = victory_core__WEBPACK_IMPORTED_MODULE_1__.isVertical(Object.assign({}, props, {\n    orientation\n  }));\n  const anchors = getAnchors(orientation, isVertical);\n  return {\n    anchors,\n    axis,\n    crossAxis,\n    domain,\n    isVertical,\n    labelPadding,\n    orientation,\n    orientations,\n    origin,\n    padding,\n    scale,\n    stringTicks,\n    style,\n    tickFormat,\n    ticks\n  };\n};\nconst getBaseProps = (initialProps, fallbackProps) => {\n  const props = victory_core__WEBPACK_IMPORTED_MODULE_1__.modifyProps(initialProps, fallbackProps);\n  const calculatedValues = getCalculatedValues(props);\n  const {\n    axis,\n    style,\n    orientation,\n    isVertical,\n    scale,\n    ticks,\n    tickFormat,\n    anchors,\n    domain,\n    stringTicks\n  } = calculatedValues;\n  const otherAxis = axis === \"x\" ? \"y\" : \"x\";\n  const {\n    width,\n    height,\n    standalone,\n    theme,\n    polar,\n    padding,\n    horizontal\n  } = props;\n  const {\n    globalTransform,\n    gridOffset,\n    gridEdge\n  } = getLayoutProps(props, calculatedValues);\n  const sharedProps = {\n    scale: {\n      [axis]: scale[axis]\n    },\n    polar,\n    horizontal,\n    ticks,\n    stringTicks\n  };\n  const axisProps = getAxisProps(props, calculatedValues, globalTransform);\n  const axisLabelProps = getAxisLabelProps(props, calculatedValues, globalTransform);\n  const initialChildProps = {\n    parent: Object.assign({\n      style: style.parent,\n      ticks,\n      standalone,\n      theme,\n      width,\n      height,\n      padding,\n      domain\n    }, sharedProps)\n  };\n  const gridProps = {\n    dimension: otherAxis,\n    range: {\n      [otherAxis]: victory_core__WEBPACK_IMPORTED_MODULE_3__.getRange(props, otherAxis)\n    },\n    scale: props.scale && props.scale[otherAxis] ? {\n      [otherAxis]: props.scale[otherAxis]\n    } : undefined\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return ticks.reduce((childProps, tickValue, index) => {\n    const tick = stringTicks ? stringTicks[index] : tickValue;\n    const text = tickFormat(tickValue, index, ticks);\n    const styles = getEvaluatedStyles(style, Object.assign({}, sharedProps, {\n      tick,\n      tickValue,\n      index,\n      text\n    }));\n    const tickLayout = {\n      position: getTickPosition(styles, orientation, isVertical),\n      transform: getTickTransform(scale[axis]?.(tickValue), globalTransform, isVertical)\n    };\n    const gridLayout = {\n      edge: gridEdge,\n      transform: {\n        x: isVertical ? -gridOffset.x + globalTransform.x : scale[axis]?.(tickValue) + globalTransform.x,\n        y: isVertical ? scale[axis]?.(tickValue) + globalTransform.y : gridOffset.y + globalTransform.y\n      }\n    };\n    childProps[index] = {\n      axis: Object.assign({\n        dimension: axis\n      }, sharedProps, axisProps),\n      axisLabel: Object.assign({}, sharedProps, axisLabelProps),\n      ticks: Object.assign({}, sharedProps, getTickProps(tickLayout, styles.tickStyle, tickValue)),\n      tickLabels: Object.assign({}, sharedProps, getTickLabelProps(tickLayout, styles.labelStyle, anchors, tickValue, text)),\n      grid: Object.assign({}, sharedProps, gridProps, getGridProps(gridLayout, styles.gridStyle, tickValue))\n    };\n    return childProps;\n  }, initialChildProps);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2VzL2hlbHBlci1tZXRob2RzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0M7QUFDWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBWTtBQUMzQjtBQUNBLGdCQUFnQixzREFBa0I7QUFDbEM7QUFDQSxnQ0FBZ0MsbURBQWM7QUFDOUMsY0FBYyxrREFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFTLEdBQUc7QUFDL0I7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVM7QUFDckIsVUFBVSxzREFBUyxHQUFHO0FBQ3RCLGVBQWUsc0RBQVMsR0FBRztBQUMzQixVQUFVLHNEQUFTLEdBQUc7QUFDdEIsV0FBVyxzREFBUyxHQUFHO0FBQ3ZCLGdCQUFnQixzREFBUyxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFxQjtBQUNwQyxnQkFBZ0IsdURBQXFCO0FBQ3JDLGVBQWUsdURBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFxQiw4QkFBOEI7QUFDekU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixzREFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQWtCO0FBQ3BDO0FBQ0Esc0JBQXNCLHFEQUFnQjtBQUN0QyxlQUFlLGlEQUFZO0FBQzNCLHFCQUFxQixtREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQWE7QUFDN0IscUJBQXFCLHVEQUFrQjtBQUN2QztBQUNBLE9BQU8sa0RBQWdCO0FBQ3ZCLE9BQU8sa0RBQWdCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNEQUFrQjtBQUMxRCx3Q0FBd0Msc0RBQWtCO0FBQzFEO0FBQ0Esd0NBQXdDLG1EQUFjO0FBQ3REO0FBQ0EsT0FBTyx1REFBa0I7QUFDekIsT0FBTyx1REFBa0I7QUFDekIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHFCQUFxQixvREFBZSxpQkFBaUI7QUFDckQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdCQUFnQixxREFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBZ0I7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0Isa0NBQWtDO0FBQ2xDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGxtdGYtdWkvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2VzL2hlbHBlci1tZXRob2RzLmpzPzhmYTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZhdWx0cyBmcm9tIFwibG9kYXNoL2RlZmF1bHRzXCI7XG5pbXBvcnQgeyBIZWxwZXJzLCBTY2FsZSwgQXhpcyB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbmNvbnN0IG9yaWVudGF0aW9uU2lnbiA9IHtcbiAgdG9wOiAtMSxcbiAgbGVmdDogLTEsXG4gIHJpZ2h0OiAxLFxuICBib3R0b206IDFcbn07XG5jb25zdCBleGlzdHMgPSB2YWwgPT4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkO1xuY29uc3QgZ2V0Q3VycmVudEF4aXMgPSAocHJvcHMsIGF4aXMpID0+IHtcbiAgY29uc3Qge1xuICAgIG9yaWVudGF0aW9uLFxuICAgIGhvcml6b250YWxcbiAgfSA9IHByb3BzO1xuICBpZiAob3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBkaW1lbnNpb25zID0ge1xuICAgICAgdG9wOiBcInhcIixcbiAgICAgIGJvdHRvbTogXCJ4XCIsXG4gICAgICBsZWZ0OiBcInlcIixcbiAgICAgIHJpZ2h0OiBcInlcIlxuICAgIH07XG4gICAgcmV0dXJuIGRpbWVuc2lvbnNbb3JpZW50YXRpb25dO1xuICB9XG4gIGNvbnN0IG90aGVyQXhpcyA9IGF4aXMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgcmV0dXJuIGhvcml6b250YWwgPyBvdGhlckF4aXMgOiBheGlzO1xufTtcbmNvbnN0IGdldFNjYWxlID0gcHJvcHMgPT4ge1xuICBjb25zdCBheGlzID0gQXhpcy5nZXRBeGlzKHByb3BzKTtcbiAgY29uc3QgY3VycmVudEF4aXMgPSBnZXRDdXJyZW50QXhpcyhwcm9wcywgYXhpcyk7XG4gIGNvbnN0IHNjYWxlID0gU2NhbGUuZ2V0QmFzZVNjYWxlKHByb3BzLCBheGlzKTtcbiAgY29uc3QgcHJvcHNEb21haW4gPSBwcm9wcy5kb21haW4gJiYgcHJvcHMuZG9tYWluW2F4aXNdO1xuICBjb25zdCBkb21haW4gPSBwcm9wc0RvbWFpbiB8fCBBeGlzLmdldERvbWFpbihwcm9wcykgfHwgc2NhbGUuZG9tYWluKCk7XG4gIHNjYWxlLnJhbmdlKEhlbHBlcnMuZ2V0UmFuZ2UocHJvcHMsIGN1cnJlbnRBeGlzKSk7XG4gIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICByZXR1cm4gc2NhbGU7XG59O1xuY29uc3QgZ2V0U3R5bGVPYmplY3QgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZSxcbiAgICBkZXBlbmRlbnRBeGlzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgZ2VuZXJhbEF4aXNTdHlsZSA9IHRoZW1lICYmIHRoZW1lLmF4aXMgJiYgdGhlbWUuYXhpcy5zdHlsZTtcbiAgY29uc3QgYXhpc1R5cGUgPSBkZXBlbmRlbnRBeGlzID8gXCJkZXBlbmRlbnRBeGlzXCIgOiBcImluZGVwZW5kZW50QXhpc1wiO1xuICBjb25zdCBzcGVjaWZpY0F4aXNTdHlsZSA9IHRoZW1lICYmIHRoZW1lW2F4aXNUeXBlXSAmJiB0aGVtZVtheGlzVHlwZV0uc3R5bGU7XG4gIGNvbnN0IG1lcmdlU3R5bGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlTmFtZXNwYWNlcyA9IFtcImF4aXNcIiwgXCJheGlzTGFiZWxcIiwgXCJncmlkXCIsIFwicGFyZW50XCIsIFwidGlja0xhYmVsc1wiLCBcInRpY2tzXCJdO1xuICAgIHJldHVybiBzdHlsZU5hbWVzcGFjZXMucmVkdWNlKChtZW1vLCBjdXJyKSA9PiB7XG4gICAgICBtZW1vW2N1cnJdID0gX2RlZmF1bHRzKHt9LCBzcGVjaWZpY0F4aXNTdHlsZVtjdXJyXSwgZ2VuZXJhbEF4aXNTdHlsZVtjdXJyXSk7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSk7XG4gIH07XG4gIHJldHVybiBnZW5lcmFsQXhpc1N0eWxlICYmIHNwZWNpZmljQXhpc1N0eWxlID8gbWVyZ2VTdHlsZXMoKSA6IHNwZWNpZmljQXhpc1N0eWxlIHx8IGdlbmVyYWxBeGlzU3R5bGU7XG59O1xuZXhwb3J0IGNvbnN0IGdldFN0eWxlcyA9IGZ1bmN0aW9uIChwcm9wcywgc3R5bGVPYmplY3QpIHtcbiAgaWYgKHN0eWxlT2JqZWN0ID09PSB2b2lkIDApIHtcbiAgICBzdHlsZU9iamVjdCA9IHt9O1xuICB9XG4gIGNvbnN0IHN0eWxlID0gcHJvcHMuc3R5bGUgfHwge307XG4gIGNvbnN0IHBhcmVudFN0eWxlUHJvcHMgPSB7XG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICB3aWR0aDogXCIxMDAlXCJcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJlbnQ6IF9kZWZhdWx0cyhzdHlsZS5wYXJlbnQsIHN0eWxlT2JqZWN0LnBhcmVudCwgcGFyZW50U3R5bGVQcm9wcyksXG4gICAgYXhpczogX2RlZmF1bHRzKHt9LCBzdHlsZS5heGlzLCBzdHlsZU9iamVjdC5heGlzKSxcbiAgICBheGlzTGFiZWw6IF9kZWZhdWx0cyh7fSwgc3R5bGUuYXhpc0xhYmVsLCBzdHlsZU9iamVjdC5heGlzTGFiZWwpLFxuICAgIGdyaWQ6IF9kZWZhdWx0cyh7fSwgc3R5bGUuZ3JpZCwgc3R5bGVPYmplY3QuZ3JpZCksXG4gICAgdGlja3M6IF9kZWZhdWx0cyh7fSwgc3R5bGUudGlja3MsIHN0eWxlT2JqZWN0LnRpY2tzKSxcbiAgICB0aWNrTGFiZWxzOiBfZGVmYXVsdHMoe30sIHN0eWxlLnRpY2tMYWJlbHMsIHN0eWxlT2JqZWN0LnRpY2tMYWJlbHMpXG4gIH07XG59O1xuY29uc3QgZ2V0VGlja1Byb3BzID0gKGxheW91dCwgc3R5bGUsIGRhdHVtKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwb3NpdGlvbixcbiAgICB0cmFuc2Zvcm1cbiAgfSA9IGxheW91dDtcbiAgcmV0dXJuIHtcbiAgICB4MTogdHJhbnNmb3JtLngsXG4gICAgeTE6IHRyYW5zZm9ybS55LFxuICAgIHgyOiB0cmFuc2Zvcm0ueCArIHBvc2l0aW9uLngyLFxuICAgIHkyOiB0cmFuc2Zvcm0ueSArIHBvc2l0aW9uLnkyLFxuICAgIHN0eWxlLFxuICAgIGRhdHVtXG4gIH07XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuY29uc3QgZ2V0VGlja0xhYmVsUHJvcHMgPSAobGF5b3V0LCBzdHlsZSwgYW5jaG9ycywgZGF0dW0sIHRleHQpID0+IHtcbiAgY29uc3Qge1xuICAgIHBvc2l0aW9uLFxuICAgIHRyYW5zZm9ybVxuICB9ID0gbGF5b3V0O1xuICByZXR1cm4ge1xuICAgIHN0eWxlLFxuICAgIHg6IHRyYW5zZm9ybS54ICsgcG9zaXRpb24ueCxcbiAgICB5OiB0cmFuc2Zvcm0ueSArIHBvc2l0aW9uLnksXG4gICAgdmVydGljYWxBbmNob3I6IGFuY2hvcnMudmVydGljYWxBbmNob3IsXG4gICAgdGV4dEFuY2hvcjogYW5jaG9ycy50ZXh0QW5jaG9yLFxuICAgIGFuZ2xlOiBzdHlsZS5hbmdsZSxcbiAgICB0ZXh0LFxuICAgIGRhdHVtXG4gIH07XG59O1xuY29uc3QgZ2V0R3JpZFByb3BzID0gKGxheW91dCwgc3R5bGUsIGRhdHVtKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBlZGdlLFxuICAgIHRyYW5zZm9ybVxuICB9ID0gbGF5b3V0O1xuICByZXR1cm4ge1xuICAgIHgxOiB0cmFuc2Zvcm0ueCxcbiAgICB5MTogdHJhbnNmb3JtLnksXG4gICAgeDI6IGVkZ2UueCArIHRyYW5zZm9ybS54LFxuICAgIHkyOiBlZGdlLnkgKyB0cmFuc2Zvcm0ueSxcbiAgICBzdHlsZSxcbiAgICBkYXR1bVxuICB9O1xufTtcbmNvbnN0IGdldEF4aXNQcm9wcyA9IChtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBnbG9iYWxUcmFuc2Zvcm0pID0+IHtcbiAgY29uc3Qge1xuICAgIHN0eWxlLFxuICAgIHBhZGRpbmcsXG4gICAgaXNWZXJ0aWNhbFxuICB9ID0gY2FsY3VsYXRlZFZhbHVlcztcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gbW9kaWZpZWRQcm9wcztcbiAgcmV0dXJuIHtcbiAgICBzdHlsZTogc3R5bGUuYXhpcyxcbiAgICB4MTogaXNWZXJ0aWNhbCA/IGdsb2JhbFRyYW5zZm9ybS54IDogcGFkZGluZy5sZWZ0ICsgZ2xvYmFsVHJhbnNmb3JtLngsXG4gICAgeDI6IGlzVmVydGljYWwgPyBnbG9iYWxUcmFuc2Zvcm0ueCA6IHdpZHRoIC0gcGFkZGluZy5yaWdodCArIGdsb2JhbFRyYW5zZm9ybS54LFxuICAgIHkxOiBpc1ZlcnRpY2FsID8gcGFkZGluZy50b3AgKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdsb2JhbFRyYW5zZm9ybS55LFxuICAgIHkyOiBpc1ZlcnRpY2FsID8gaGVpZ2h0IC0gcGFkZGluZy5ib3R0b20gKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdsb2JhbFRyYW5zZm9ybS55XG4gIH07XG59O1xuY29uc3QgZ2V0RXZhbHVhdGVkU3R5bGVzID0gKHN0eWxlLCBwcm9wcykgPT4ge1xuICByZXR1cm4ge1xuICAgIHRpY2tTdHlsZTogSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLnRpY2tzLCBwcm9wcyksXG4gICAgbGFiZWxTdHlsZTogSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLnRpY2tMYWJlbHMsIHByb3BzKSxcbiAgICBncmlkU3R5bGU6IEhlbHBlcnMuZXZhbHVhdGVTdHlsZShzdHlsZS5ncmlkLCBwcm9wcylcbiAgfTtcbn07XG5jb25zdCBnZXRBeGlzTGFiZWxQcm9wcyA9IChwcm9wcywgY2FsY3VsYXRlZFZhbHVlcywgZ2xvYmFsVHJhbnNmb3JtKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdHlsZSxcbiAgICBvcmllbnRhdGlvbixcbiAgICBwYWRkaW5nLFxuICAgIGxhYmVsUGFkZGluZyxcbiAgICBpc1ZlcnRpY2FsXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCBzaWduID0gb3JpZW50YXRpb25TaWduW29yaWVudGF0aW9uXTtcbiAgY29uc3QgaFBhZGRpbmcgPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICBjb25zdCB2UGFkZGluZyA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gIGNvbnN0IHZlcnRpY2FsQW5jaG9yID0gc2lnbiA8IDAgPyBcImVuZFwiIDogXCJzdGFydFwiO1xuICBjb25zdCBsYWJlbFN0eWxlID0gc3R5bGUuYXhpc0xhYmVsO1xuICBjb25zdCBhbmdsZSA9IGlzVmVydGljYWwgPyAtOTAgOiAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgY29uc3QgeCA9IGlzVmVydGljYWwgPyBnbG9iYWxUcmFuc2Zvcm0ueCArIHNpZ24gKiBsYWJlbFBhZGRpbmcgOiAocHJvcHMud2lkdGggLSBoUGFkZGluZykgLyAyICsgcGFkZGluZy5sZWZ0ICsgZ2xvYmFsVHJhbnNmb3JtLng7XG4gIGNvbnN0IHkgPSBpc1ZlcnRpY2FsID8gKHByb3BzLmhlaWdodCAtIHZQYWRkaW5nKSAvIDIgKyBwYWRkaW5nLnRvcCArIGdsb2JhbFRyYW5zZm9ybS55IDogc2lnbiAqIGxhYmVsUGFkZGluZyArIGdsb2JhbFRyYW5zZm9ybS55O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB2ZXJ0aWNhbEFuY2hvcjogbGFiZWxTdHlsZS52ZXJ0aWNhbEFuY2hvciB8fCB2ZXJ0aWNhbEFuY2hvcixcbiAgICB0ZXh0QW5jaG9yOiBsYWJlbFN0eWxlLnRleHRBbmNob3IgfHwgXCJtaWRkbGVcIixcbiAgICBhbmdsZTogbGFiZWxTdHlsZS5hbmdsZSA9PT0gdW5kZWZpbmVkID8gYW5nbGUgOiBsYWJlbFN0eWxlLmFuZ2xlLFxuICAgIHN0eWxlOiBsYWJlbFN0eWxlLFxuICAgIHRleHQ6IHByb3BzLmxhYmVsXG4gIH07XG59O1xuY29uc3QgZ2V0QW5jaG9ycyA9IChvcmllbnRhdGlvbiwgaXNWZXJ0aWNhbCkgPT4ge1xuICBjb25zdCBhbmNob3JPcmllbnRhdGlvbiA9IHtcbiAgICB0b3A6IFwiZW5kXCIsXG4gICAgbGVmdDogXCJlbmRcIixcbiAgICByaWdodDogXCJzdGFydFwiLFxuICAgIGJvdHRvbTogXCJzdGFydFwiXG4gIH07XG4gIGNvbnN0IGFuY2hvciA9IGFuY2hvck9yaWVudGF0aW9uW29yaWVudGF0aW9uXTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0QW5jaG9yOiBpc1ZlcnRpY2FsID8gYW5jaG9yIDogXCJtaWRkbGVcIixcbiAgICB2ZXJ0aWNhbEFuY2hvcjogaXNWZXJ0aWNhbCA/IFwibWlkZGxlXCIgOiBhbmNob3JcbiAgfTtcbn07XG5jb25zdCBnZXRMYWJlbFBhZGRpbmcgPSAocHJvcHMsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGxhYmVsU3R5bGUgPSBzdHlsZS5heGlzTGFiZWwgfHwge307XG4gIGlmIChsYWJlbFN0eWxlLnBhZGRpbmcgIT09IHVuZGVmaW5lZCAmJiBsYWJlbFN0eWxlLnBhZGRpbmcgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbGFiZWxTdHlsZS5wYWRkaW5nO1xuICB9XG4gIGNvbnN0IGlzVmVydGljYWwgPSBBeGlzLmlzVmVydGljYWwocHJvcHMpO1xuICAvLyBUT0RPOiBtYWdpYyBudW1iZXJzXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW1hZ2ljLW51bWJlcnMqL1xuICBjb25zdCBmb250U2l6ZSA9IGxhYmVsU3R5bGUuZm9udFNpemUgfHwgMTQ7XG4gIHJldHVybiBwcm9wcy5sYWJlbCA/IGZvbnRTaXplICogKGlzVmVydGljYWwgPyAyLjMgOiAxLjYpIDogMDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1tYWdpYy1udW1iZXJzKi9cbn07XG5jb25zdCBnZXREZWZhdWx0T3JpZW50YXRpb25zID0gKGF4aXMsIG9yaWdpblNpZ24sIGhvcml6b250YWwpID0+IHtcbiAgY29uc3Qgc2lnbiA9IG9yaWdpblNpZ24gfHwgXCJwb3NpdGl2ZVwiO1xuICBjb25zdCBvcmllbnRhdGlvbnMgPSB7XG4gICAgcG9zaXRpdmU6IHtcbiAgICAgIHg6IFwiYm90dG9tXCIsXG4gICAgICB5OiBcImxlZnRcIlxuICAgIH0sXG4gICAgbmVnYXRpdmU6IHtcbiAgICAgIHg6IFwidG9wXCIsXG4gICAgICB5OiBcInJpZ2h0XCJcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhvcml6b250YWxPcmllbnRhdGlvbnMgPSB7XG4gICAgcG9zaXRpdmU6IHtcbiAgICAgIHg6IFwibGVmdFwiLFxuICAgICAgeTogXCJib3R0b21cIlxuICAgIH0sXG4gICAgbmVnYXRpdmU6IHtcbiAgICAgIHg6IFwicmlnaHRcIixcbiAgICAgIHk6IFwidG9wXCJcbiAgICB9XG4gIH07XG4gIHJldHVybiBob3Jpem9udGFsID8gaG9yaXpvbnRhbE9yaWVudGF0aW9uc1tzaWduXVtheGlzXSA6IG9yaWVudGF0aW9uc1tzaWduXVtheGlzXTtcbn07XG5jb25zdCBnZXRTdGFuZGFsb25lT2Zmc2V0ID0gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdHlsZSxcbiAgICBzY2FsZSxcbiAgICBvcmllbnRhdGlvbixcbiAgICBwYWRkaW5nLFxuICAgIGF4aXMsXG4gICAgdGlja3MsXG4gICAgc3RyaW5nVGlja3MsXG4gICAgaXNWZXJ0aWNhbCxcbiAgICBsYWJlbFBhZGRpbmdcbiAgfSA9IGNhbGN1bGF0ZWRWYWx1ZXM7XG4gIGNvbnN0IHtcbiAgICBwb2xhcixcbiAgICBob3Jpem9udGFsXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgc2hhcmVkUHJvcHMgPSB7XG4gICAgc2NhbGU6IHtcbiAgICAgIFtheGlzXTogc2NhbGVcbiAgICB9LFxuICAgIHBvbGFyLFxuICAgIGhvcml6b250YWwsXG4gICAgdGlja3MsXG4gICAgc3RyaW5nVGlja3NcbiAgfTtcbiAgY29uc3QgeFBhZGRpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gcGFkZGluZy5yaWdodCA6IHBhZGRpbmcubGVmdDtcbiAgY29uc3QgeVBhZGRpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJ0b3BcIiA/IHBhZGRpbmcudG9wIDogcGFkZGluZy5ib3R0b207XG4gIGNvbnN0IG9mZnNldFggPSBwcm9wcy5vZmZzZXRYICE9PSBudWxsICYmIHByb3BzLm9mZnNldFggIT09IHVuZGVmaW5lZCA/IHByb3BzLm9mZnNldFggOiB4UGFkZGluZztcbiAgY29uc3Qgb2Zmc2V0WSA9IHByb3BzLm9mZnNldFkgIT09IG51bGwgJiYgcHJvcHMub2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gcHJvcHMub2Zmc2V0WSA6IHlQYWRkaW5nO1xuICBjb25zdCBmb250U2l6ZSA9IHN0eWxlLmF4aXNMYWJlbC5mb250U2l6ZSB8fCAxNDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIGNvbnN0IHRpY2tTaXplcyA9IHRpY2tzLm1hcCgoZGF0YSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB0aWNrID0gc3RyaW5nVGlja3MgPyBwcm9wcy50aWNrVmFsdWVzW2RhdGEgLSAxXSA6IGRhdGE7XG4gICAgY29uc3QgdGlja1N0eWxlID0gSGVscGVycy5ldmFsdWF0ZVN0eWxlKHN0eWxlLnRpY2tzLCBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRQcm9wcywge1xuICAgICAgdGljayxcbiAgICAgIGluZGV4XG4gICAgfSkpO1xuICAgIHJldHVybiB0aWNrU3R5bGUuc2l6ZSB8fCAwO1xuICB9KTtcbiAgY29uc3QgdG90YWxQYWRkaW5nID0gZm9udFNpemUgKyAyICogTWF0aC5tYXgoLi4udGlja1NpemVzKSArIGxhYmVsUGFkZGluZztcbiAgY29uc3QgbWluaW11bVBhZGRpbmcgPSAxLjIgKiBmb250U2l6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIGNvbnN0IHggPSBpc1ZlcnRpY2FsID8gdG90YWxQYWRkaW5nIDogbWluaW11bVBhZGRpbmc7XG4gIGNvbnN0IHkgPSBpc1ZlcnRpY2FsID8gbWluaW11bVBhZGRpbmcgOiB0b3RhbFBhZGRpbmc7XG4gIHJldHVybiB7XG4gICAgeDogb2Zmc2V0WCAhPT0gbnVsbCAmJiBvZmZzZXRYICE9PSB1bmRlZmluZWQgPyBvZmZzZXRYIDogeCxcbiAgICB5OiBvZmZzZXRZICE9PSBudWxsICYmIG9mZnNldFkgIT09IHVuZGVmaW5lZCA/IG9mZnNldFkgOiB5XG4gIH07XG59O1xuY29uc3QgaXNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gIH1cbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuY29uc3QgZ2V0T2Zmc2V0ID0gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzY2FsZSxcbiAgICBvcmlnaW4sXG4gICAgb3JpZW50YXRpb24sXG4gICAgb3JpZW50YXRpb25zLFxuICAgIGRvbWFpbixcbiAgICBwYWRkaW5nXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH0gPSBwYWRkaW5nO1xuICBjb25zdCBjYWxjdWxhdGVkT3JpZW50YXRpb24gPSB7XG4gICAgeDogb3JpZW50YXRpb24gPT09IFwiYm90dG9tXCIgfHwgb3JpZW50YXRpb24gPT09IFwidG9wXCIgPyBvcmllbnRhdGlvbiA6IG9yaWVudGF0aW9ucy54LFxuICAgIHk6IG9yaWVudGF0aW9uID09PSBcImxlZnRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gb3JpZW50YXRpb24gOiBvcmllbnRhdGlvbnMueVxuICB9O1xuXG4gIC8vIG1ha2UgdGhlIGF4ZXMgbGluZSB1cCwgYW5kIGNyb3NzIHdoZW4gYXBwcm9wcmlhdGVcbiAgY29uc3Qgb3JpZW50YXRpb25PZmZzZXQgPSB7XG4gICAgeDogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnkgPT09IFwibGVmdFwiID8gbGVmdCA6IHJpZ2h0LFxuICAgIHk6IGNhbGN1bGF0ZWRPcmllbnRhdGlvbi54ID09PSBcImJvdHRvbVwiID8gYm90dG9tIDogdG9wXG4gIH07XG4gIGNvbnN0IG9yaWdpbk9mZnNldCA9IHtcbiAgICB4OiBjYWxjdWxhdGVkT3JpZW50YXRpb24ueSA9PT0gXCJsZWZ0XCIgPyAwIDogcHJvcHMud2lkdGgsXG4gICAgeTogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnggPT09IFwiYm90dG9tXCIgPyBwcm9wcy5oZWlnaHQgOiAwXG4gIH07XG4gIGNvbnN0IG9yaWdpblBvc2l0aW9uID0ge1xuICAgIHg6IGlzRXF1YWwob3JpZ2luLngsIGRvbWFpbi54WzBdKSB8fCBpc0VxdWFsKG9yaWdpbi54LCBkb21haW4ueFsxXSkgPyAwIDogc2NhbGUueChvcmlnaW4ueCksXG4gICAgeTogaXNFcXVhbChvcmlnaW4ueSwgZG9tYWluLnlbMF0pIHx8IGlzRXF1YWwob3JpZ2luLnksIGRvbWFpbi55WzFdKSA/IDAgOiBzY2FsZS55KG9yaWdpbi55KVxuICB9O1xuICBjb25zdCB4ID0gb3JpZ2luUG9zaXRpb24ueCA/IE1hdGguYWJzKG9yaWdpbk9mZnNldC54IC0gb3JpZ2luUG9zaXRpb24ueCkgOiBvcmllbnRhdGlvbk9mZnNldC54O1xuICBjb25zdCB5ID0gb3JpZ2luUG9zaXRpb24ueSA/IE1hdGguYWJzKG9yaWdpbk9mZnNldC55IC0gb3JpZ2luUG9zaXRpb24ueSkgOiBvcmllbnRhdGlvbk9mZnNldC55O1xuICBjb25zdCBvZmZzZXRYID0gZXhpc3RzKHByb3BzLm9mZnNldFgpID8gcHJvcHMub2Zmc2V0WCA6IHg7XG4gIGNvbnN0IG9mZnNldFkgPSBleGlzdHMocHJvcHMub2Zmc2V0WSkgPyBwcm9wcy5vZmZzZXRZIDogeTtcbiAgcmV0dXJuIHtcbiAgICB4OiBvZmZzZXRYLFxuICAgIHk6IG9mZnNldFlcbiAgfTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5jb25zdCBnZXRIb3Jpem9udGFsT2Zmc2V0ID0gKHByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzY2FsZSxcbiAgICBvcmlnaW4sXG4gICAgb3JpZW50YXRpb24sXG4gICAgb3JpZW50YXRpb25zLFxuICAgIGRvbWFpbixcbiAgICBwYWRkaW5nXG4gIH0gPSBjYWxjdWxhdGVkVmFsdWVzO1xuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH0gPSBwYWRkaW5nO1xuICBjb25zdCBjYWxjdWxhdGVkT3JpZW50YXRpb24gPSB7XG4gICAgeTogb3JpZW50YXRpb24gPT09IFwiYm90dG9tXCIgfHwgb3JpZW50YXRpb24gPT09IFwidG9wXCIgPyBvcmllbnRhdGlvbiA6IG9yaWVudGF0aW9ucy54LFxuICAgIHg6IG9yaWVudGF0aW9uID09PSBcImxlZnRcIiB8fCBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gb3JpZW50YXRpb24gOiBvcmllbnRhdGlvbnMueVxuICB9O1xuXG4gIC8vIG1ha2UgdGhlIGF4ZXMgbGluZSB1cCwgYW5kIGNyb3NzIHdoZW4gYXBwcm9wcmlhdGVcbiAgY29uc3Qgb3JpZW50YXRpb25PZmZzZXQgPSB7XG4gICAgeDogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnkgPT09IFwiYm90dG9tXCIgPyBib3R0b20gOiB0b3AsXG4gICAgeTogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnggPT09IFwibGVmdFwiID8gbGVmdCA6IHJpZ2h0XG4gIH07XG4gIGNvbnN0IG9yaWdpbk9mZnNldCA9IHtcbiAgICB5OiBjYWxjdWxhdGVkT3JpZW50YXRpb24ueCA9PT0gXCJsZWZ0XCIgPyAwIDogcHJvcHMud2lkdGgsXG4gICAgeDogY2FsY3VsYXRlZE9yaWVudGF0aW9uLnkgPT09IFwiYm90dG9tXCIgPyBwcm9wcy5oZWlnaHQgOiAwXG4gIH07XG4gIGNvbnN0IG9yaWdpblBvc2l0aW9uID0ge1xuICAgIHg6IGlzRXF1YWwob3JpZ2luLngsIGRvbWFpbi54WzBdKSB8fCBpc0VxdWFsKG9yaWdpbi54LCBkb21haW4ueFsxXSkgPyAwIDogc2NhbGUueChvcmlnaW4ueCksXG4gICAgeTogaXNFcXVhbChvcmlnaW4ueSwgZG9tYWluLnlbMF0pIHx8IGlzRXF1YWwob3JpZ2luLnksIGRvbWFpbi55WzFdKSA/IDAgOiBzY2FsZS55KG9yaWdpbi55KVxuICB9O1xuICBjb25zdCB5ID0gb3JpZ2luUG9zaXRpb24ueCA/IE1hdGguYWJzKG9yaWdpbk9mZnNldC54IC0gb3JpZ2luUG9zaXRpb24ueCkgOiBvcmllbnRhdGlvbk9mZnNldC54O1xuICBjb25zdCB4ID0gb3JpZ2luUG9zaXRpb24ueSA/IE1hdGguYWJzKG9yaWdpbk9mZnNldC55IC0gb3JpZ2luUG9zaXRpb24ueSkgOiBvcmllbnRhdGlvbk9mZnNldC55O1xuICBjb25zdCBvZmZzZXRYID0gZXhpc3RzKHByb3BzLm9mZnNldFgpID8gcHJvcHMub2Zmc2V0WCA6IHg7XG4gIGNvbnN0IG9mZnNldFkgPSBleGlzdHMocHJvcHMub2Zmc2V0WSkgPyBwcm9wcy5vZmZzZXRZIDogeTtcbiAgcmV0dXJuIHtcbiAgICB4OiBvZmZzZXRYLFxuICAgIHk6IG9mZnNldFlcbiAgfTtcbn07XG5jb25zdCBnZXRUcmFuc2Zvcm0gPSAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIG9mZnNldCkgPT4ge1xuICBjb25zdCB7XG4gICAgb3JpZW50YXRpb24sXG4gICAgYXhpc1xuICB9ID0gY2FsY3VsYXRlZFZhbHVlcztcbiAgY29uc3QgYXhpc1ZhbHVlID0gQXhpcy5nZXRBeGlzVmFsdWUocHJvcHMsIGF4aXMpO1xuICByZXR1cm4ge1xuICAgIHRvcDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IGF4aXNWYWx1ZSAhPT0gdW5kZWZpbmVkID8gYXhpc1ZhbHVlIDogb2Zmc2V0LnlcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgeDogMCxcbiAgICAgIHk6IGF4aXNWYWx1ZSAhPT0gdW5kZWZpbmVkID8gYXhpc1ZhbHVlIDogcHJvcHMuaGVpZ2h0IC0gb2Zmc2V0LnlcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHg6IGF4aXNWYWx1ZSAhPT0gdW5kZWZpbmVkID8gYXhpc1ZhbHVlIDogb2Zmc2V0LngsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgeDogYXhpc1ZhbHVlICE9PSB1bmRlZmluZWQgPyBheGlzVmFsdWUgOiBwcm9wcy53aWR0aCAtIG9mZnNldC54LFxuICAgICAgeTogMFxuICAgIH1cbiAgfVtvcmllbnRhdGlvbl07XG59O1xuY29uc3QgZ2V0VGlja1Bvc2l0aW9uID0gKHN0eWxlLCBvcmllbnRhdGlvbiwgaXNWZXJ0aWNhbCkgPT4ge1xuICBjb25zdCB7XG4gICAgdGlja1N0eWxlLFxuICAgIGxhYmVsU3R5bGVcbiAgfSA9IHN0eWxlO1xuICBjb25zdCBzaXplID0gdGlja1N0eWxlLnNpemUgfHwgMDtcbiAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrU3R5bGUucGFkZGluZyB8fCAwO1xuICBjb25zdCBsYWJlbFBhZGRpbmcgPSBsYWJlbFN0eWxlLnBhZGRpbmcgfHwgMDtcbiAgY29uc3QgdGlja1NwYWNpbmcgPSBzaXplICsgdGlja1BhZGRpbmcgKyBsYWJlbFBhZGRpbmc7XG4gIGNvbnN0IHNpZ24gPSBvcmllbnRhdGlvblNpZ25bb3JpZW50YXRpb25dO1xuICByZXR1cm4ge1xuICAgIHg6IGlzVmVydGljYWwgPyBzaWduICogdGlja1NwYWNpbmcgOiAwLFxuICAgIHgyOiBpc1ZlcnRpY2FsID8gc2lnbiAqIHNpemUgOiAwLFxuICAgIHk6IGlzVmVydGljYWwgPyAwIDogc2lnbiAqIHRpY2tTcGFjaW5nLFxuICAgIHkyOiBpc1ZlcnRpY2FsID8gMCA6IHNpZ24gKiBzaXplXG4gIH07XG59O1xuY29uc3QgZ2V0VGlja1RyYW5zZm9ybSA9ICh0aWNrLCBnbG9iYWxUcmFuc2Zvcm0sIGlzVmVydGljYWwpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc1ZlcnRpY2FsID8gZ2xvYmFsVHJhbnNmb3JtLnggOiB0aWNrICsgZ2xvYmFsVHJhbnNmb3JtLngsXG4gICAgeTogaXNWZXJ0aWNhbCA/IHRpY2sgKyBnbG9iYWxUcmFuc2Zvcm0ueSA6IGdsb2JhbFRyYW5zZm9ybS55XG4gIH07XG59O1xuY29uc3QgZ2V0R3JpZEVkZ2UgPSAocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpID0+IHtcbiAgY29uc3Qge1xuICAgIG9yaWVudGF0aW9uLFxuICAgIHBhZGRpbmcsXG4gICAgaXNWZXJ0aWNhbFxuICB9ID0gY2FsY3VsYXRlZFZhbHVlcztcbiAgY29uc3Qgc2lnbiA9IC1vcmllbnRhdGlvblNpZ25bb3JpZW50YXRpb25dO1xuICBjb25zdCB4ID0gaXNWZXJ0aWNhbCA/IHNpZ24gKiAocHJvcHMud2lkdGggLSAocGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCkpIDogMDtcbiAgY29uc3QgeSA9IGlzVmVydGljYWwgPyAwIDogc2lnbiAqIChwcm9wcy5oZWlnaHQgLSAocGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufTtcbmNvbnN0IGdldEdyaWRPZmZzZXQgPSAoY2FsY3VsYXRlZFZhbHVlcywgb2Zmc2V0KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwYWRkaW5nLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIGNyb3NzQXhpc1xuICB9ID0gY2FsY3VsYXRlZFZhbHVlcztcbiAgY29uc3QgeFBhZGRpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJyaWdodFwiID8gcGFkZGluZy5yaWdodCA6IHBhZGRpbmcubGVmdDtcbiAgY29uc3QgeVBhZGRpbmcgPSBvcmllbnRhdGlvbiA9PT0gXCJ0b3BcIiA/IHBhZGRpbmcudG9wIDogcGFkZGluZy5ib3R0b207XG4gIHJldHVybiB7XG4gICAgeDogY3Jvc3NBeGlzID8gb2Zmc2V0LnggLSB4UGFkZGluZyA6IDAsXG4gICAgeTogY3Jvc3NBeGlzID8gb2Zmc2V0LnkgLSB5UGFkZGluZyA6IDBcbiAgfTtcbn07XG5jb25zdCBnZXRMYXlvdXRQcm9wcyA9IChtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzKSA9PiB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChjYWxjdWxhdGVkVmFsdWVzLmRvbWFpbi54ICYmIGNhbGN1bGF0ZWRWYWx1ZXMuZG9tYWluLnkpIHtcbiAgICBvZmZzZXQgPSBtb2RpZmllZFByb3BzLmhvcml6b250YWwgPyBnZXRIb3Jpem9udGFsT2Zmc2V0KG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpIDogZ2V0T2Zmc2V0KG1vZGlmaWVkUHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IGdldFN0YW5kYWxvbmVPZmZzZXQobW9kaWZpZWRQcm9wcywgY2FsY3VsYXRlZFZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnbG9iYWxUcmFuc2Zvcm06IGdldFRyYW5zZm9ybShtb2RpZmllZFByb3BzLCBjYWxjdWxhdGVkVmFsdWVzLCBvZmZzZXQpLFxuICAgIGdyaWRPZmZzZXQ6IGdldEdyaWRPZmZzZXQoY2FsY3VsYXRlZFZhbHVlcywgb2Zmc2V0KSxcbiAgICBncmlkRWRnZTogZ2V0R3JpZEVkZ2UobW9kaWZpZWRQcm9wcywgY2FsY3VsYXRlZFZhbHVlcylcbiAgfTtcbn07XG5jb25zdCBnZXRPcmllbnRhdGlvbiA9IHByb3BzID0+IHtcbiAgaWYgKHByb3BzLm9yaWVudGF0aW9uKSB7XG4gICAgcmV0dXJuIHByb3BzLm9yaWVudGF0aW9uO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRPcmllbnRhdGlvbnMgPSB7XG4gICAgZGVwZW5kZW50OiBwcm9wcy5ob3Jpem9udGFsID8gXCJib3R0b21cIiA6IFwibGVmdFwiLFxuICAgIGluZGVwZW5kZW50OiBwcm9wcy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiXG4gIH07XG4gIHJldHVybiBwcm9wcy5kZXBlbmRlbnRBeGlzID8gZGVmYXVsdE9yaWVudGF0aW9ucy5kZXBlbmRlbnQgOiBkZWZhdWx0T3JpZW50YXRpb25zLmluZGVwZW5kZW50O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmNvbnN0IGdldENhbGN1bGF0ZWRWYWx1ZXMgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZXMgPSBnZXRTdHlsZU9iamVjdChwcm9wcyk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGVzKHByb3BzLCBkZWZhdWx0U3R5bGVzKTtcbiAgY29uc3QgcGFkZGluZyA9IEhlbHBlcnMuZ2V0UGFkZGluZyhwcm9wcyk7XG4gIGNvbnN0IGxhYmVsUGFkZGluZyA9IGdldExhYmVsUGFkZGluZyhwcm9wcywgc3R5bGUpO1xuICBjb25zdCBzdHJpbmdUaWNrcyA9IEF4aXMuc3RyaW5nVGlja3MocHJvcHMpID8gcHJvcHMudGlja1ZhbHVlcyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgYXhpcyA9IEF4aXMuZ2V0QXhpcyhwcm9wcyk7XG4gIGNvbnN0IGF4aXNEb21haW4gPSBBeGlzLmdldERvbWFpbihwcm9wcyk7XG4gIGNvbnN0IGF4aXNTY2FsZSA9IGdldFNjYWxlKHByb3BzKTtcbiAgY29uc3QgeEF4aXNEb21haW4gPSBheGlzID09PSBcInhcIiA/IGF4aXNEb21haW4gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHlBeGlzRG9tYWluID0gYXhpcyA9PT0gXCJ5XCIgPyBheGlzRG9tYWluIDogdW5kZWZpbmVkO1xuICBjb25zdCB4QXhpc1NjYWxlID0gYXhpcyA9PT0gXCJ4XCIgPyBheGlzU2NhbGUgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHlBeGlzU2NhbGUgPSBheGlzID09PSBcInlcIiA/IGF4aXNTY2FsZSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgY3Jvc3NBeGlzID0gIShwcm9wcy5jcm9zc0F4aXMgPT09IGZhbHNlIHx8IHByb3BzLnN0YW5kYWxvbmUgPT09IHRydWUpO1xuICBjb25zdCB0aWNrcyA9IEF4aXMuZ2V0VGlja3MocHJvcHMsIGF4aXNTY2FsZSwgY3Jvc3NBeGlzKTtcbiAgY29uc3QgdGlja0Zvcm1hdCA9IEF4aXMuZ2V0VGlja0Zvcm1hdChwcm9wcywgYXhpc1NjYWxlKTtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgeDogSGVscGVycy5nZXRSYW5nZShwcm9wcywgXCJ4XCIpLFxuICAgIHk6IEhlbHBlcnMuZ2V0UmFuZ2UocHJvcHMsIFwieVwiKVxuICB9O1xuICAvLyB1c2UgZnVsbCBkb21haW4gaWYgcGFzc2VkIGluIGZyb20gcGFyZW50LFxuICAvLyBvdGhlcndpc2UgdXNlIHRoZSBqdXN0IHRoZSBvbmUgYXhpcyBhdmFpbGFibGVcbiAgY29uc3QgZG9tYWluID0ge1xuICAgIHg6IHByb3BzLmRvbWFpbiAmJiBwcm9wcy5kb21haW4ueCA/IHByb3BzLmRvbWFpbi54IDogeEF4aXNEb21haW4sXG4gICAgeTogcHJvcHMuZG9tYWluICYmIHByb3BzLmRvbWFpbi55ID8gcHJvcHMuZG9tYWluLnkgOiB5QXhpc0RvbWFpblxuICB9O1xuICAvLyB1c2UgZnVsbCBzY2FsZSBpZiBwYXNzZWQgaW4gZnJvbSBwYXJlbnQsXG4gIC8vIG90aGVyd2lzZSB1c2UgdGhlIGp1c3QgdGhlIG9uZSBheGlzIGF2YWlsYWJsZVxuICBjb25zdCBzY2FsZSA9IHtcbiAgICB4OiBwcm9wcy5kb21haW4gJiYgcHJvcHMuZG9tYWluLnggPyBTY2FsZS5nZXRCYXNlU2NhbGUocHJvcHMsIFwieFwiKS5kb21haW4ocHJvcHMuZG9tYWluLngpLnJhbmdlKHByb3BzLmhvcml6b250YWwgPyByYW5nZS55IDogcmFuZ2UueCkgOiB4QXhpc1NjYWxlLFxuICAgIHk6IHByb3BzLmRvbWFpbiAmJiBwcm9wcy5kb21haW4ueSA/IFNjYWxlLmdldEJhc2VTY2FsZShwcm9wcywgXCJ5XCIpLmRvbWFpbihwcm9wcy5kb21haW4ueSkucmFuZ2UocHJvcHMuaG9yaXpvbnRhbCA/IHJhbmdlLnggOiByYW5nZS55KSA6IHlBeGlzU2NhbGVcbiAgfTtcbiAgY29uc3Qgb3JpZ2luID0gZG9tYWluLnggJiYgZG9tYWluLnkgPyBBeGlzLmdldE9yaWdpbihkb21haW4pIDogdW5kZWZpbmVkO1xuICBjb25zdCBvcmlnaW5TaWduID0gb3JpZ2luID8ge1xuICAgIHg6IEF4aXMuZ2V0T3JpZ2luU2lnbihvcmlnaW4ueCwgZG9tYWluLngpLFxuICAgIHk6IEF4aXMuZ2V0T3JpZ2luU2lnbihvcmlnaW4ueSwgZG9tYWluLnkpXG4gIH0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWVudGF0aW9ucyA9IG9yaWdpblNpZ24gPyB7XG4gICAgeDogZ2V0RGVmYXVsdE9yaWVudGF0aW9ucyhcInhcIiwgb3JpZ2luU2lnbi55LCBwcm9wcy5ob3Jpem9udGFsKSxcbiAgICB5OiBnZXREZWZhdWx0T3JpZW50YXRpb25zKFwieVwiLCBvcmlnaW5TaWduLngsIHByb3BzLmhvcml6b250YWwpXG4gIH0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG9yaWVudGF0aW9uID0gb3JpZW50YXRpb25zID8gcHJvcHMub3JpZW50YXRpb24gfHwgb3JpZW50YXRpb25zW2F4aXNdIDogZ2V0T3JpZW50YXRpb24ocHJvcHMpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gQXhpcy5pc1ZlcnRpY2FsKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgb3JpZW50YXRpb25cbiAgfSkpO1xuICBjb25zdCBhbmNob3JzID0gZ2V0QW5jaG9ycyhvcmllbnRhdGlvbiwgaXNWZXJ0aWNhbCk7XG4gIHJldHVybiB7XG4gICAgYW5jaG9ycyxcbiAgICBheGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBkb21haW4sXG4gICAgaXNWZXJ0aWNhbCxcbiAgICBsYWJlbFBhZGRpbmcsXG4gICAgb3JpZW50YXRpb24sXG4gICAgb3JpZW50YXRpb25zLFxuICAgIG9yaWdpbixcbiAgICBwYWRkaW5nLFxuICAgIHNjYWxlLFxuICAgIHN0cmluZ1RpY2tzLFxuICAgIHN0eWxlLFxuICAgIHRpY2tGb3JtYXQsXG4gICAgdGlja3NcbiAgfTtcbn07XG5leHBvcnQgY29uc3QgZ2V0QmFzZVByb3BzID0gKGluaXRpYWxQcm9wcywgZmFsbGJhY2tQcm9wcykgPT4ge1xuICBjb25zdCBwcm9wcyA9IEF4aXMubW9kaWZ5UHJvcHMoaW5pdGlhbFByb3BzLCBmYWxsYmFja1Byb3BzKTtcbiAgY29uc3QgY2FsY3VsYXRlZFZhbHVlcyA9IGdldENhbGN1bGF0ZWRWYWx1ZXMocHJvcHMpO1xuICBjb25zdCB7XG4gICAgYXhpcyxcbiAgICBzdHlsZSxcbiAgICBvcmllbnRhdGlvbixcbiAgICBpc1ZlcnRpY2FsLFxuICAgIHNjYWxlLFxuICAgIHRpY2tzLFxuICAgIHRpY2tGb3JtYXQsXG4gICAgYW5jaG9ycyxcbiAgICBkb21haW4sXG4gICAgc3RyaW5nVGlja3NcbiAgfSA9IGNhbGN1bGF0ZWRWYWx1ZXM7XG4gIGNvbnN0IG90aGVyQXhpcyA9IGF4aXMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBzdGFuZGFsb25lLFxuICAgIHRoZW1lLFxuICAgIHBvbGFyLFxuICAgIHBhZGRpbmcsXG4gICAgaG9yaXpvbnRhbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBnbG9iYWxUcmFuc2Zvcm0sXG4gICAgZ3JpZE9mZnNldCxcbiAgICBncmlkRWRnZVxuICB9ID0gZ2V0TGF5b3V0UHJvcHMocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMpO1xuICBjb25zdCBzaGFyZWRQcm9wcyA9IHtcbiAgICBzY2FsZToge1xuICAgICAgW2F4aXNdOiBzY2FsZVtheGlzXVxuICAgIH0sXG4gICAgcG9sYXIsXG4gICAgaG9yaXpvbnRhbCxcbiAgICB0aWNrcyxcbiAgICBzdHJpbmdUaWNrc1xuICB9O1xuICBjb25zdCBheGlzUHJvcHMgPSBnZXRBeGlzUHJvcHMocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIGdsb2JhbFRyYW5zZm9ybSk7XG4gIGNvbnN0IGF4aXNMYWJlbFByb3BzID0gZ2V0QXhpc0xhYmVsUHJvcHMocHJvcHMsIGNhbGN1bGF0ZWRWYWx1ZXMsIGdsb2JhbFRyYW5zZm9ybSk7XG4gIGNvbnN0IGluaXRpYWxDaGlsZFByb3BzID0ge1xuICAgIHBhcmVudDogT2JqZWN0LmFzc2lnbih7XG4gICAgICBzdHlsZTogc3R5bGUucGFyZW50LFxuICAgICAgdGlja3MsXG4gICAgICBzdGFuZGFsb25lLFxuICAgICAgdGhlbWUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBkb21haW5cbiAgICB9LCBzaGFyZWRQcm9wcylcbiAgfTtcbiAgY29uc3QgZ3JpZFByb3BzID0ge1xuICAgIGRpbWVuc2lvbjogb3RoZXJBeGlzLFxuICAgIHJhbmdlOiB7XG4gICAgICBbb3RoZXJBeGlzXTogSGVscGVycy5nZXRSYW5nZShwcm9wcywgb3RoZXJBeGlzKVxuICAgIH0sXG4gICAgc2NhbGU6IHByb3BzLnNjYWxlICYmIHByb3BzLnNjYWxlW290aGVyQXhpc10gPyB7XG4gICAgICBbb3RoZXJBeGlzXTogcHJvcHMuc2NhbGVbb3RoZXJBeGlzXVxuICAgIH0gOiB1bmRlZmluZWRcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICByZXR1cm4gdGlja3MucmVkdWNlKChjaGlsZFByb3BzLCB0aWNrVmFsdWUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdGljayA9IHN0cmluZ1RpY2tzID8gc3RyaW5nVGlja3NbaW5kZXhdIDogdGlja1ZhbHVlO1xuICAgIGNvbnN0IHRleHQgPSB0aWNrRm9ybWF0KHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRFdmFsdWF0ZWRTdHlsZXMoc3R5bGUsIE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZFByb3BzLCB7XG4gICAgICB0aWNrLFxuICAgICAgdGlja1ZhbHVlLFxuICAgICAgaW5kZXgsXG4gICAgICB0ZXh0XG4gICAgfSkpO1xuICAgIGNvbnN0IHRpY2tMYXlvdXQgPSB7XG4gICAgICBwb3NpdGlvbjogZ2V0VGlja1Bvc2l0aW9uKHN0eWxlcywgb3JpZW50YXRpb24sIGlzVmVydGljYWwpLFxuICAgICAgdHJhbnNmb3JtOiBnZXRUaWNrVHJhbnNmb3JtKHNjYWxlW2F4aXNdPy4odGlja1ZhbHVlKSwgZ2xvYmFsVHJhbnNmb3JtLCBpc1ZlcnRpY2FsKVxuICAgIH07XG4gICAgY29uc3QgZ3JpZExheW91dCA9IHtcbiAgICAgIGVkZ2U6IGdyaWRFZGdlLFxuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIHg6IGlzVmVydGljYWwgPyAtZ3JpZE9mZnNldC54ICsgZ2xvYmFsVHJhbnNmb3JtLnggOiBzY2FsZVtheGlzXT8uKHRpY2tWYWx1ZSkgKyBnbG9iYWxUcmFuc2Zvcm0ueCxcbiAgICAgICAgeTogaXNWZXJ0aWNhbCA/IHNjYWxlW2F4aXNdPy4odGlja1ZhbHVlKSArIGdsb2JhbFRyYW5zZm9ybS55IDogZ3JpZE9mZnNldC55ICsgZ2xvYmFsVHJhbnNmb3JtLnlcbiAgICAgIH1cbiAgICB9O1xuICAgIGNoaWxkUHJvcHNbaW5kZXhdID0ge1xuICAgICAgYXhpczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGRpbWVuc2lvbjogYXhpc1xuICAgICAgfSwgc2hhcmVkUHJvcHMsIGF4aXNQcm9wcyksXG4gICAgICBheGlzTGFiZWw6IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZFByb3BzLCBheGlzTGFiZWxQcm9wcyksXG4gICAgICB0aWNrczogT2JqZWN0LmFzc2lnbih7fSwgc2hhcmVkUHJvcHMsIGdldFRpY2tQcm9wcyh0aWNrTGF5b3V0LCBzdHlsZXMudGlja1N0eWxlLCB0aWNrVmFsdWUpKSxcbiAgICAgIHRpY2tMYWJlbHM6IE9iamVjdC5hc3NpZ24oe30sIHNoYXJlZFByb3BzLCBnZXRUaWNrTGFiZWxQcm9wcyh0aWNrTGF5b3V0LCBzdHlsZXMubGFiZWxTdHlsZSwgYW5jaG9ycywgdGlja1ZhbHVlLCB0ZXh0KSksXG4gICAgICBncmlkOiBPYmplY3QuYXNzaWduKHt9LCBzaGFyZWRQcm9wcywgZ3JpZFByb3BzLCBnZXRHcmlkUHJvcHMoZ3JpZExheW91dCwgc3R5bGVzLmdyaWRTdHlsZSwgdGlja1ZhbHVlKSlcbiAgICB9O1xuICAgIHJldHVybiBjaGlsZFByb3BzO1xuICB9LCBpbml0aWFsQ2hpbGRQcm9wcyk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-axis/es/helper-methods.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/victory-axis/es/victory-axis.js":
/*!******************************************************!*\
  !*** ./node_modules/victory-axis/es/victory-axis.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VictoryAxis: () => (/* binding */ VictoryAxis)\n/* harmony export */ });\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEmpty */ \"(ssr)/./node_modules/lodash/isEmpty.js\");\n/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-primitives/line-segment.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-label/victory-label.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-theme/victory-theme.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-container/victory-container.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/axis.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/textsize.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/user-props.js\");\n/* harmony import */ var victory_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! victory-core */ \"(ssr)/./node_modules/victory-core/es/victory-util/add-events.js\");\n/* harmony import */ var _helper_methods__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helper-methods */ \"(ssr)/./node_modules/victory-axis/es/helper-methods.js\");\n\n\n\n\nconst fallbackProps = {\n  width: 450,\n  height: 300,\n  padding: 50\n};\nconst options = {\n  components: [{\n    name: \"axis\",\n    index: 0\n  }, {\n    name: \"axisLabel\",\n    index: 0\n  }, {\n    name: \"grid\"\n  }, {\n    name: \"parent\",\n    index: \"parent\"\n  }, {\n    name: \"ticks\"\n  }, {\n    name: \"tickLabels\"\n  }]\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\nclass VictoryAxisBase extends (react__WEBPACK_IMPORTED_MODULE_1___default().Component) {\n  static animationWhitelist = [\"style\", \"domain\", \"range\", \"tickCount\", \"tickValues\", \"offsetX\", \"offsetY\", \"padding\", \"width\", \"height\"];\n  static displayName = \"VictoryAxis\";\n  static role = \"axis\";\n  static defaultTransitions = {\n    onExit: {\n      duration: 500\n    },\n    onEnter: {\n      duration: 500\n    }\n  };\n  static defaultProps = {\n    axisComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(victory_core__WEBPACK_IMPORTED_MODULE_2__.LineSegment, null),\n    axisLabelComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(victory_core__WEBPACK_IMPORTED_MODULE_3__.VictoryLabel, null),\n    tickLabelComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(victory_core__WEBPACK_IMPORTED_MODULE_3__.VictoryLabel, null),\n    tickComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(victory_core__WEBPACK_IMPORTED_MODULE_2__.LineSegment, null),\n    gridComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(victory_core__WEBPACK_IMPORTED_MODULE_2__.LineSegment, null),\n    standalone: true,\n    theme: victory_core__WEBPACK_IMPORTED_MODULE_4__.VictoryTheme.grayscale,\n    containerComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(victory_core__WEBPACK_IMPORTED_MODULE_5__.VictoryContainer, null),\n    groupComponent: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"g\", {\n      role: \"presentation\"\n    }),\n    fixLabelOverlap: false\n  };\n  static getDomain = victory_core__WEBPACK_IMPORTED_MODULE_6__.getDomain;\n  static getAxis = victory_core__WEBPACK_IMPORTED_MODULE_6__.getAxis;\n  static getStyles(props) {\n    return (0,_helper_methods__WEBPACK_IMPORTED_MODULE_7__.getStyles)(props);\n  }\n  static getBaseProps(props) {\n    return (0,_helper_methods__WEBPACK_IMPORTED_MODULE_7__.getBaseProps)(props, fallbackProps);\n  }\n  static expectedComponents = [\"axisComponent\", \"axisLabelComponent\", \"groupComponent\", \"containerComponent\", \"tickComponent\", \"tickLabelComponent\", \"gridComponent\"];\n  renderLine(props) {\n    const {\n      axisComponent\n    } = props;\n    const axisProps = this.getComponentProps(axisComponent, \"axis\", 0);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(axisComponent, axisProps);\n  }\n  renderLabel(props) {\n    const {\n      axisLabelComponent,\n      label\n    } = props;\n    if (!label) {\n      return null;\n    }\n    const axisLabelProps = this.getComponentProps(axisLabelComponent, \"axisLabel\", 0);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(axisLabelComponent, axisLabelProps);\n  }\n  renderGridAndTicks(props) {\n    const {\n      tickComponent,\n      tickLabelComponent,\n      gridComponent,\n      name\n    } = props;\n    const shouldRender = componentProps => {\n      const {\n        style = {},\n        events = {}\n      } = componentProps;\n      const visible = style.stroke !== \"transparent\" && style.stroke !== \"none\" && style.strokeWidth !== 0;\n      return visible || !lodash_isEmpty__WEBPACK_IMPORTED_MODULE_0___default()(events);\n    };\n    return this.dataKeys.map((key, index) => {\n      const tickProps = this.getComponentProps(tickComponent, \"ticks\", index);\n      const BaseTickComponent = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(tickComponent, tickProps);\n      const TickComponent = shouldRender(BaseTickComponent.props) ? BaseTickComponent : undefined;\n      const gridProps = this.getComponentProps(gridComponent, \"grid\", index);\n      const BaseGridComponent = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(gridComponent, gridProps);\n      const GridComponent = shouldRender(BaseGridComponent.props) ? BaseGridComponent : undefined;\n      const tickLabelProps = this.getComponentProps(tickLabelComponent, \"tickLabels\", index);\n      const TickLabel = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(tickLabelComponent, tickLabelProps);\n      const children = [GridComponent, TickComponent, TickLabel].filter(Boolean);\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(props.groupComponent, {\n        key: `${name}-tick-group-${key}`\n      }, children);\n    });\n  }\n  fixLabelOverlap(gridAndTicks, props) {\n    const isVertical = victory_core__WEBPACK_IMPORTED_MODULE_6__.isVertical(props);\n    const size = isVertical ? props.height : props.width;\n    const isVictoryLabel = child => child.type && child.type.role === \"label\";\n    const labels = gridAndTicks.map(gridAndTick => gridAndTick.props.children).reduce((accumulator, childArr) => accumulator.concat(childArr), []).filter(isVictoryLabel).map(child => child.props);\n    const paddingToObject = padding => typeof padding === \"object\" ? Object.assign({}, {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, padding) : {\n      top: padding,\n      right: padding,\n      bottom: padding,\n      left: padding\n    };\n    const labelsSumSize = labels.reduce((sum, label) => {\n      const padding = paddingToObject(label.style.padding);\n      const labelSize = victory_core__WEBPACK_IMPORTED_MODULE_8__.approximateTextSize(label.text, {\n        angle: label.angle,\n        fontSize: label.style.fontSize,\n        letterSpacing: label.style.letterSpacing,\n        fontFamily: label.style.fontFamily\n      });\n      return sum + (isVertical ? labelSize.height + padding.top + padding.bottom : labelSize.width + padding.right + padding.left);\n    }, 0);\n    const availiableLabelCount = Math.floor(size * gridAndTicks.length / labelsSumSize);\n    const divider = Math.ceil(gridAndTicks.length / availiableLabelCount) || 1;\n    const getLabelCoord = gridAndTick => gridAndTick.props.children.filter(isVictoryLabel).reduce((prev, child) => (isVertical ? child.props.y : child.props.x) || 0, 0);\n    const sorted = gridAndTicks.sort((a, b) => isVertical ? getLabelCoord(b) - getLabelCoord(a) // ordinary axis has top-bottom orientation\n    : getLabelCoord(a) - getLabelCoord(b) // ordinary axis has left-right orientation\n    );\n    return sorted.filter((gridAndTick, index) => index % divider === 0);\n  }\n\n  // Overridden in native versions\n  shouldAnimate() {\n    return !!this.props.animate;\n  }\n  render() {\n    const {\n      animationWhitelist\n    } = VictoryAxis;\n    const props = victory_core__WEBPACK_IMPORTED_MODULE_6__.modifyProps(this.props, fallbackProps);\n    const userProps = victory_core__WEBPACK_IMPORTED_MODULE_9__.getSafeUserProps(this.props);\n    if (this.shouldAnimate()) {\n      return this.animateComponent(props, animationWhitelist);\n    }\n    const gridAndTicks = this.renderGridAndTicks(props);\n    const modifiedGridAndTicks = props.fixLabelOverlap ? this.fixLabelOverlap(gridAndTicks, props) : gridAndTicks;\n    const children = [this.renderLine(props), this.renderLabel(props), ...modifiedGridAndTicks];\n    const container = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(props.containerComponent, userProps);\n    return props.standalone ? this.renderContainer(container, children) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(props.groupComponent, userProps, children);\n  }\n}\nconst VictoryAxis = (0,victory_core__WEBPACK_IMPORTED_MODULE_10__.addEvents)(VictoryAxisBase, options);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmljdG9yeS1heGlzL2VzL3ZpY3RvcnktYXhpcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNaO0FBQ3FHO0FBQ3BFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsOEJBQThCLHdEQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUFtQixDQUFDLHFEQUFXO0FBQy9ELHFDQUFxQywwREFBbUIsQ0FBQyxzREFBWTtBQUNyRSxxQ0FBcUMsMERBQW1CLENBQUMsc0RBQVk7QUFDckUsZ0NBQWdDLDBEQUFtQixDQUFDLHFEQUFXO0FBQy9ELGdDQUFnQywwREFBbUIsQ0FBQyxxREFBVztBQUMvRDtBQUNBLFdBQVcsc0RBQVk7QUFDdkIscUNBQXFDLDBEQUFtQixDQUFDLDBEQUFnQjtBQUN6RSxpQ0FBaUMsMERBQW1CO0FBQ3BEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsbURBQWM7QUFDbkMsbUJBQW1CLGlEQUFZO0FBQy9CO0FBQ0EsV0FBVywwREFBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyw2REFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCLHlEQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsUUFBUTtBQUNSO0FBQ0EseUJBQXlCLHFEQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx5REFBa0I7QUFDL0Q7QUFDQTtBQUNBLDZDQUE2Qyx5REFBa0I7QUFDL0Q7QUFDQTtBQUNBLHFDQUFxQyx5REFBa0I7QUFDdkQ7QUFDQSwwQkFBMEIseURBQWtCO0FBQzVDLGdCQUFnQixLQUFLLGNBQWMsSUFBSTtBQUN2QyxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZEQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixxREFBZ0I7QUFDbEMsc0JBQXNCLDBEQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQWtCO0FBQ3JELHVGQUF1Rix5REFBa0I7QUFDekc7QUFDQTtBQUNPLG9CQUFvQix3REFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2xsbXRmLXVpLy4vbm9kZV9tb2R1bGVzL3ZpY3RvcnktYXhpcy9lcy92aWN0b3J5LWF4aXMuanM/OWYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2lzRW1wdHkgZnJvbSBcImxvZGFzaC9pc0VtcHR5XCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBWaWN0b3J5TGFiZWwsIFZpY3RvcnlDb250YWluZXIsIFZpY3RvcnlUaGVtZSwgTGluZVNlZ21lbnQsIFRleHRTaXplLCBhZGRFdmVudHMsIEF4aXMsIFVzZXJQcm9wcyB9IGZyb20gXCJ2aWN0b3J5LWNvcmVcIjtcbmltcG9ydCB7IGdldEJhc2VQcm9wcywgZ2V0U3R5bGVzIH0gZnJvbSBcIi4vaGVscGVyLW1ldGhvZHNcIjtcbmNvbnN0IGZhbGxiYWNrUHJvcHMgPSB7XG4gIHdpZHRoOiA0NTAsXG4gIGhlaWdodDogMzAwLFxuICBwYWRkaW5nOiA1MFxufTtcbmNvbnN0IG9wdGlvbnMgPSB7XG4gIGNvbXBvbmVudHM6IFt7XG4gICAgbmFtZTogXCJheGlzXCIsXG4gICAgaW5kZXg6IDBcbiAgfSwge1xuICAgIG5hbWU6IFwiYXhpc0xhYmVsXCIsXG4gICAgaW5kZXg6IDBcbiAgfSwge1xuICAgIG5hbWU6IFwiZ3JpZFwiXG4gIH0sIHtcbiAgICBuYW1lOiBcInBhcmVudFwiLFxuICAgIGluZGV4OiBcInBhcmVudFwiXG4gIH0sIHtcbiAgICBuYW1lOiBcInRpY2tzXCJcbiAgfSwge1xuICAgIG5hbWU6IFwidGlja0xhYmVsc1wiXG4gIH1dXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZVxuXG5jbGFzcyBWaWN0b3J5QXhpc0Jhc2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgYW5pbWF0aW9uV2hpdGVsaXN0ID0gW1wic3R5bGVcIiwgXCJkb21haW5cIiwgXCJyYW5nZVwiLCBcInRpY2tDb3VudFwiLCBcInRpY2tWYWx1ZXNcIiwgXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiLCBcInBhZGRpbmdcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXTtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJWaWN0b3J5QXhpc1wiO1xuICBzdGF0aWMgcm9sZSA9IFwiYXhpc1wiO1xuICBzdGF0aWMgZGVmYXVsdFRyYW5zaXRpb25zID0ge1xuICAgIG9uRXhpdDoge1xuICAgICAgZHVyYXRpb246IDUwMFxuICAgIH0sXG4gICAgb25FbnRlcjoge1xuICAgICAgZHVyYXRpb246IDUwMFxuICAgIH1cbiAgfTtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBheGlzQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lU2VnbWVudCwgbnVsbCksXG4gICAgYXhpc0xhYmVsQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5TGFiZWwsIG51bGwpLFxuICAgIHRpY2tMYWJlbENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmljdG9yeUxhYmVsLCBudWxsKSxcbiAgICB0aWNrQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lU2VnbWVudCwgbnVsbCksXG4gICAgZ3JpZENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluZVNlZ21lbnQsIG51bGwpLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgdGhlbWU6IFZpY3RvcnlUaGVtZS5ncmF5c2NhbGUsXG4gICAgY29udGFpbmVyQ29tcG9uZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChWaWN0b3J5Q29udGFpbmVyLCBudWxsKSxcbiAgICBncm91cENvbXBvbmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICAgIHJvbGU6IFwicHJlc2VudGF0aW9uXCJcbiAgICB9KSxcbiAgICBmaXhMYWJlbE92ZXJsYXA6IGZhbHNlXG4gIH07XG4gIHN0YXRpYyBnZXREb21haW4gPSBBeGlzLmdldERvbWFpbjtcbiAgc3RhdGljIGdldEF4aXMgPSBBeGlzLmdldEF4aXM7XG4gIHN0YXRpYyBnZXRTdHlsZXMocHJvcHMpIHtcbiAgICByZXR1cm4gZ2V0U3R5bGVzKHByb3BzKTtcbiAgfVxuICBzdGF0aWMgZ2V0QmFzZVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIGdldEJhc2VQcm9wcyhwcm9wcywgZmFsbGJhY2tQcm9wcyk7XG4gIH1cbiAgc3RhdGljIGV4cGVjdGVkQ29tcG9uZW50cyA9IFtcImF4aXNDb21wb25lbnRcIiwgXCJheGlzTGFiZWxDb21wb25lbnRcIiwgXCJncm91cENvbXBvbmVudFwiLCBcImNvbnRhaW5lckNvbXBvbmVudFwiLCBcInRpY2tDb21wb25lbnRcIiwgXCJ0aWNrTGFiZWxDb21wb25lbnRcIiwgXCJncmlkQ29tcG9uZW50XCJdO1xuICByZW5kZXJMaW5lKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhpc0NvbXBvbmVudFxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBheGlzUHJvcHMgPSB0aGlzLmdldENvbXBvbmVudFByb3BzKGF4aXNDb21wb25lbnQsIFwiYXhpc1wiLCAwKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChheGlzQ29tcG9uZW50LCBheGlzUHJvcHMpO1xuICB9XG4gIHJlbmRlckxhYmVsKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXhpc0xhYmVsQ29tcG9uZW50LFxuICAgICAgbGFiZWxcbiAgICB9ID0gcHJvcHM7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGF4aXNMYWJlbFByb3BzID0gdGhpcy5nZXRDb21wb25lbnRQcm9wcyhheGlzTGFiZWxDb21wb25lbnQsIFwiYXhpc0xhYmVsXCIsIDApO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGF4aXNMYWJlbENvbXBvbmVudCwgYXhpc0xhYmVsUHJvcHMpO1xuICB9XG4gIHJlbmRlckdyaWRBbmRUaWNrcyhwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpY2tDb21wb25lbnQsXG4gICAgICB0aWNrTGFiZWxDb21wb25lbnQsXG4gICAgICBncmlkQ29tcG9uZW50LFxuICAgICAgbmFtZVxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCBzaG91bGRSZW5kZXIgPSBjb21wb25lbnRQcm9wcyA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlID0ge30sXG4gICAgICAgIGV2ZW50cyA9IHt9XG4gICAgICB9ID0gY29tcG9uZW50UHJvcHM7XG4gICAgICBjb25zdCB2aXNpYmxlID0gc3R5bGUuc3Ryb2tlICE9PSBcInRyYW5zcGFyZW50XCIgJiYgc3R5bGUuc3Ryb2tlICE9PSBcIm5vbmVcIiAmJiBzdHlsZS5zdHJva2VXaWR0aCAhPT0gMDtcbiAgICAgIHJldHVybiB2aXNpYmxlIHx8ICFfaXNFbXB0eShldmVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZGF0YUtleXMubWFwKChrZXksIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB0aWNrUHJvcHMgPSB0aGlzLmdldENvbXBvbmVudFByb3BzKHRpY2tDb21wb25lbnQsIFwidGlja3NcIiwgaW5kZXgpO1xuICAgICAgY29uc3QgQmFzZVRpY2tDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHRpY2tDb21wb25lbnQsIHRpY2tQcm9wcyk7XG4gICAgICBjb25zdCBUaWNrQ29tcG9uZW50ID0gc2hvdWxkUmVuZGVyKEJhc2VUaWNrQ29tcG9uZW50LnByb3BzKSA/IEJhc2VUaWNrQ29tcG9uZW50IDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZ3JpZFByb3BzID0gdGhpcy5nZXRDb21wb25lbnRQcm9wcyhncmlkQ29tcG9uZW50LCBcImdyaWRcIiwgaW5kZXgpO1xuICAgICAgY29uc3QgQmFzZUdyaWRDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGdyaWRDb21wb25lbnQsIGdyaWRQcm9wcyk7XG4gICAgICBjb25zdCBHcmlkQ29tcG9uZW50ID0gc2hvdWxkUmVuZGVyKEJhc2VHcmlkQ29tcG9uZW50LnByb3BzKSA/IEJhc2VHcmlkQ29tcG9uZW50IDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgdGlja0xhYmVsUHJvcHMgPSB0aGlzLmdldENvbXBvbmVudFByb3BzKHRpY2tMYWJlbENvbXBvbmVudCwgXCJ0aWNrTGFiZWxzXCIsIGluZGV4KTtcbiAgICAgIGNvbnN0IFRpY2tMYWJlbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQodGlja0xhYmVsQ29tcG9uZW50LCB0aWNrTGFiZWxQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IFtHcmlkQ29tcG9uZW50LCBUaWNrQ29tcG9uZW50LCBUaWNrTGFiZWxdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHByb3BzLmdyb3VwQ29tcG9uZW50LCB7XG4gICAgICAgIGtleTogYCR7bmFtZX0tdGljay1ncm91cC0ke2tleX1gXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfSk7XG4gIH1cbiAgZml4TGFiZWxPdmVybGFwKGdyaWRBbmRUaWNrcywgcHJvcHMpIHtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gQXhpcy5pc1ZlcnRpY2FsKHByb3BzKTtcbiAgICBjb25zdCBzaXplID0gaXNWZXJ0aWNhbCA/IHByb3BzLmhlaWdodCA6IHByb3BzLndpZHRoO1xuICAgIGNvbnN0IGlzVmljdG9yeUxhYmVsID0gY2hpbGQgPT4gY2hpbGQudHlwZSAmJiBjaGlsZC50eXBlLnJvbGUgPT09IFwibGFiZWxcIjtcbiAgICBjb25zdCBsYWJlbHMgPSBncmlkQW5kVGlja3MubWFwKGdyaWRBbmRUaWNrID0+IGdyaWRBbmRUaWNrLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjaGlsZEFycikgPT4gYWNjdW11bGF0b3IuY29uY2F0KGNoaWxkQXJyKSwgW10pLmZpbHRlcihpc1ZpY3RvcnlMYWJlbCkubWFwKGNoaWxkID0+IGNoaWxkLnByb3BzKTtcbiAgICBjb25zdCBwYWRkaW5nVG9PYmplY3QgPSBwYWRkaW5nID0+IHR5cGVvZiBwYWRkaW5nID09PSBcIm9iamVjdFwiID8gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfSwgcGFkZGluZykgOiB7XG4gICAgICB0b3A6IHBhZGRpbmcsXG4gICAgICByaWdodDogcGFkZGluZyxcbiAgICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICAgIGxlZnQ6IHBhZGRpbmdcbiAgICB9O1xuICAgIGNvbnN0IGxhYmVsc1N1bVNpemUgPSBsYWJlbHMucmVkdWNlKChzdW0sIGxhYmVsKSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gcGFkZGluZ1RvT2JqZWN0KGxhYmVsLnN0eWxlLnBhZGRpbmcpO1xuICAgICAgY29uc3QgbGFiZWxTaXplID0gVGV4dFNpemUuYXBwcm94aW1hdGVUZXh0U2l6ZShsYWJlbC50ZXh0LCB7XG4gICAgICAgIGFuZ2xlOiBsYWJlbC5hbmdsZSxcbiAgICAgICAgZm9udFNpemU6IGxhYmVsLnN0eWxlLmZvbnRTaXplLFxuICAgICAgICBsZXR0ZXJTcGFjaW5nOiBsYWJlbC5zdHlsZS5sZXR0ZXJTcGFjaW5nLFxuICAgICAgICBmb250RmFtaWx5OiBsYWJlbC5zdHlsZS5mb250RmFtaWx5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdW0gKyAoaXNWZXJ0aWNhbCA/IGxhYmVsU2l6ZS5oZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tIDogbGFiZWxTaXplLndpZHRoICsgcGFkZGluZy5yaWdodCArIHBhZGRpbmcubGVmdCk7XG4gICAgfSwgMCk7XG4gICAgY29uc3QgYXZhaWxpYWJsZUxhYmVsQ291bnQgPSBNYXRoLmZsb29yKHNpemUgKiBncmlkQW5kVGlja3MubGVuZ3RoIC8gbGFiZWxzU3VtU2l6ZSk7XG4gICAgY29uc3QgZGl2aWRlciA9IE1hdGguY2VpbChncmlkQW5kVGlja3MubGVuZ3RoIC8gYXZhaWxpYWJsZUxhYmVsQ291bnQpIHx8IDE7XG4gICAgY29uc3QgZ2V0TGFiZWxDb29yZCA9IGdyaWRBbmRUaWNrID0+IGdyaWRBbmRUaWNrLnByb3BzLmNoaWxkcmVuLmZpbHRlcihpc1ZpY3RvcnlMYWJlbCkucmVkdWNlKChwcmV2LCBjaGlsZCkgPT4gKGlzVmVydGljYWwgPyBjaGlsZC5wcm9wcy55IDogY2hpbGQucHJvcHMueCkgfHwgMCwgMCk7XG4gICAgY29uc3Qgc29ydGVkID0gZ3JpZEFuZFRpY2tzLnNvcnQoKGEsIGIpID0+IGlzVmVydGljYWwgPyBnZXRMYWJlbENvb3JkKGIpIC0gZ2V0TGFiZWxDb29yZChhKSAvLyBvcmRpbmFyeSBheGlzIGhhcyB0b3AtYm90dG9tIG9yaWVudGF0aW9uXG4gICAgOiBnZXRMYWJlbENvb3JkKGEpIC0gZ2V0TGFiZWxDb29yZChiKSAvLyBvcmRpbmFyeSBheGlzIGhhcyBsZWZ0LXJpZ2h0IG9yaWVudGF0aW9uXG4gICAgKTtcbiAgICByZXR1cm4gc29ydGVkLmZpbHRlcigoZ3JpZEFuZFRpY2ssIGluZGV4KSA9PiBpbmRleCAlIGRpdmlkZXIgPT09IDApO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGRlbiBpbiBuYXRpdmUgdmVyc2lvbnNcbiAgc2hvdWxkQW5pbWF0ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnByb3BzLmFuaW1hdGU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuaW1hdGlvbldoaXRlbGlzdFxuICAgIH0gPSBWaWN0b3J5QXhpcztcbiAgICBjb25zdCBwcm9wcyA9IEF4aXMubW9kaWZ5UHJvcHModGhpcy5wcm9wcywgZmFsbGJhY2tQcm9wcyk7XG4gICAgY29uc3QgdXNlclByb3BzID0gVXNlclByb3BzLmdldFNhZmVVc2VyUHJvcHModGhpcy5wcm9wcyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlQ29tcG9uZW50KHByb3BzLCBhbmltYXRpb25XaGl0ZWxpc3QpO1xuICAgIH1cbiAgICBjb25zdCBncmlkQW5kVGlja3MgPSB0aGlzLnJlbmRlckdyaWRBbmRUaWNrcyhwcm9wcyk7XG4gICAgY29uc3QgbW9kaWZpZWRHcmlkQW5kVGlja3MgPSBwcm9wcy5maXhMYWJlbE92ZXJsYXAgPyB0aGlzLmZpeExhYmVsT3ZlcmxhcChncmlkQW5kVGlja3MsIHByb3BzKSA6IGdyaWRBbmRUaWNrcztcbiAgICBjb25zdCBjaGlsZHJlbiA9IFt0aGlzLnJlbmRlckxpbmUocHJvcHMpLCB0aGlzLnJlbmRlckxhYmVsKHByb3BzKSwgLi4ubW9kaWZpZWRHcmlkQW5kVGlja3NdO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocHJvcHMuY29udGFpbmVyQ29tcG9uZW50LCB1c2VyUHJvcHMpO1xuICAgIHJldHVybiBwcm9wcy5zdGFuZGFsb25lID8gdGhpcy5yZW5kZXJDb250YWluZXIoY29udGFpbmVyLCBjaGlsZHJlbikgOiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHByb3BzLmdyb3VwQ29tcG9uZW50LCB1c2VyUHJvcHMsIGNoaWxkcmVuKTtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IFZpY3RvcnlBeGlzID0gYWRkRXZlbnRzKFZpY3RvcnlBeGlzQmFzZSwgb3B0aW9ucyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/victory-axis/es/victory-axis.js\n");

/***/ })

};
;